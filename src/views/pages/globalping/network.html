<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/gp-header.html" name="c-gp-header">
<link rel="ractive" href="../../components/gp-footer.html" name="c-gp-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	{{#if !@shared.isServer && !@shared.googleMapsLoaded}}
		<script>
			function onDocumentReady (fn) {
				if (document.readyState !== 'loading') {
					fn();
				} else {
					document.addEventListener('DOMContentLoaded', fn);
				}
			}
			/* eslint-disable */
			function initMap () {
				onDocumentReady(function () {
					app.loaded = true;

					if (app.router.route && app.router.route.view && app.router.route.view.initMap) {
						app.router.route.view.initMap();
					}
				});
			}
		</script>
		<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBTICLY5LgWNJ0Uly61Q1sNXz_1KZIECwg&amp;language=en&amp;callback=initMap&loading=async" async></script>
	{{/if}}

	<c-notification></c-notification>

	<c-gp-header additionalClasses="header-with-globalping-bg"></c-gp-header>

	<div class="p-globalping-network">
		<div class="gp-network">
			<div class="gp-network_map-wrapper">
				<div id="gp-map" class="gp-network_map-wrapper_map"></div>
			</div>

			<div class="gp-network_filters">
				<span class="gp-network_filters_title">
					<img width="20" height="20" src="{{@shared.assetsHost}}/img/globalping/filter-icon.svg">
					<span>Filters:</span>
				</span>

				<div class="gp-network_filters_list">
					{{#each filtersSet}}
						<span class="gp-network_filters_list_selected">
							{{this.name}}

							<img on-click="@this.rmFilterRule(@key)"
								width="16"
								height="16"
								src="{{@shared.assetsHost}}/img/globalping/tag-input-close-icon.svg">
						</span>
					{{/each}}

					{{#each availableFilters}}
						{{#unless this.selected}}
							<span on-click="@this.setFilterRule(@key)" class="gp-network_filters_list_item">
								{{this.name}}
							</span>
						{{/unless}}
					{{/each}}
				</div>
			</div>

			<div class="gp-network_list">
				{{#each filteredProbes as data}}
					<span class="gp-network_list_item cont-header">{{@key}}</span>
					{{#each data as probe}}
						<span class="gp-network_list_item">
							<img width="17"
								height="12"
								src="https://cdn.jsdelivr.net/npm/country-flag-icons@1.5.5/3x2/{{probe.location.country}}.svg">

							<span>{{probe.location.country}}, {{probe.location.city}}</span>

							{{#if probe.probesInCity && probe.probesInCity !== 1}}
								<span>(x{{probe.probesInCity}})</span>
							{{/if}}
						</span>
					{{/each}}
				{{/each}}
			</div>
		</div>
	</div>

	<c-gp-footer></c-gp-footer>
</r-page>

<script>
	const debounce = require('../../../assets/js/utils/debounce');
	const throttle = require('../../../assets/js/utils/throttle');
	const has = require('../../../assets/js/utils/has');
	const http = require('../../../assets/js/utils/http');
	const CONTINENTS = require('../../../assets/json/continents.json');
	const INITIAL_MAP_STYLES = require('../../../assets/js/map/styles.json');
	const MAP_MIN_ZOOM = 2;
	const MAP_MAX_ZOOM = 22;
	const MAP_ZOOM_REG = 3.74;
	const MAP_ZOOM_ALT = 2.14;
	const MAP_CENTER_REG = { lat: 48, lng: 16 };
	const MAP_CENTER_ALT = { lat: 30, lng: 18 };
	const MODERATE_MAP_STYLES = [
		...INITIAL_MAP_STYLES,
		{
			elementType: 'labels.text.stroke',
			stylers: [{ visibility: 'on' }],
		},
		{
			elementType: 'labels.text.fill',
			stylers: [
				{ visibility: 'on' },
				{ color: '#989b9e' },
			],
		},
	];
	const DETAILED_MAP_STYLES = [
		...MODERATE_MAP_STYLES,
		{
			featureType: 'road',
			stylers: [{ visibility: 'on' }],
		},
	];
	let map;

	component.exports = {
		data () {
			return {
				title: 'Network - Globalping',
				description: 'Network - Globalping',
				availableFilters: [
					{
						name: 'Europe',
						value: 'EU',
						type: 'byContinent',
					},
					{
						name: 'North America',
						value: 'NA',
						type: 'byContinent',
					},
					{
						name: 'South America',
						value: 'SA',
						type: 'byContinent',
					},
					{
						name: 'Africa',
						value: 'AF',
						type: 'byContinent',
					},
					{
						name: 'Asia',
						value: 'AS',
						type: 'byContinent',
					},
					{
						name: 'Oceania',
						value: 'OC',
						type: 'byContinent',
					},
					{
						name: 'eyeball network',
						value: 'eyeball-network',
						type: 'byTag',
					},
					{
						name: 'datacenter',
						value: 'datacenter-network',
						type: 'byTag',
					},
					{
						name: 'Google Cloud',
						value: 'TODO',
						type: 'TODO',
					},
					{
						name: 'AWS Cloud',
						value: 'TODO',
						type: 'TODO',
					},
				],
				probesResponse: null,
				probesByContinents: null,
				filteredProbes: null,
				filtersSet: null,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				// get probes from sessionStorage or fetch them and handle
				this.getProbesData();

				// set initial screenWidth value
				this.observe('screenWidth', (screenWidth) => {
					if (!screenWidth) {
						this.set('screenWidth', innerWidth);
					}
				});

				// sort probes by continents, and each list by country name
				this.observe('probesResponse', (probesResponse) => {
					if (probesResponse) {
						let probesByContinents = this.sortByContinents(probesResponse);

						this.set('probesByContinents', probesByContinents);
					}
				});

				// use filters for the probesByContinents before render
				this.observe('filtersSet', (filtersSet) => {
					let probesByContinents = this.get('probesByContinents');
					let filteredProbes = this.get('filteredProbes') || probesByContinents;

					if (filtersSet) {
						filteredProbes = this.getFilteredProbesList(filtersSet, filteredProbes);
					} else {
						filteredProbes = probesByContinents;
					}

					this.set('filteredProbes', filteredProbes);
				});
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				this.set('@shared.googleMapsLoaded', true);

				if (app.loaded) {
					this.initMap();
				}

				// detect window resize
				window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
			}
		},
		initMap () {
			let mq = window.matchMedia('(min-width: 768px)');

			map = new google.maps.Map(this.find('#gp-map'), {
				styles: INITIAL_MAP_STYLES,
				zoom: MAP_ZOOM_REG,
				center: MAP_CENTER_REG,
				mapTypeId: 'roadmap',
				draggableCursor: 'default',
				mapTypeControl: false,
				streetViewControl: false,
				fullscreenControl: false,
				minZoom: MAP_MIN_ZOOM,
				maxZoom: MAP_MAX_ZOOM,
			});

			if (mq.matches) {
				map.setCenter(MAP_CENTER_ALT);
				map.setZoom(MAP_ZOOM_ALT);
			}

			// while zooming handle marker positions for those with the same coordinates
			map.addListener('zoom_changed', () => {
				let currZoom = map.getZoom();

				// handle map detalization on zoom
				if (currZoom >= 14) {
					map.setOptions({ styles: DETAILED_MAP_STYLES });
				} else if (currZoom >= 5) {
					map.setOptions({ styles: MODERATE_MAP_STYLES });
				} else {
					map.setOptions({ styles: INITIAL_MAP_STYLES });
				}
			});
		},
		getProbesData () {
			if (has.sessionStorage()) {
				let probesResponse = sessionStorage.getItem('probesResponse');

				if (probesResponse) {
					this.handleProbesResponse(true)(probesResponse);
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}
			} else {
				http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
			}
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.set('probesResponse', response);
			};
		},
		sortByContinents (probes) {
			// sort by continents
			let probesByContinent = probes.reduce((res, probe) => {
				let contName = this.getContinentName(probe.location.continent);

				if (!Object.hasOwn(res, contName)) {
					res[contName] = [];
				}

				// check if there are probes in the same country and city already presented and count them
				let alreadyExisted = res[contName].find(p => p.location.city === probe.location.city && p.location.country === probe.location.country);

				if (alreadyExisted) {
					alreadyExisted.probesInCity += 1;
				} else {
					res[contName].push({ ...probe, probesInCity: 1 });
				}

				return res;
			}, {});

			// sort by countries
			return Object.keys(probesByContinent).reduce((res, key) => {
				res[key] = probesByContinent[key].sort((a, b) => a.location.country.localeCompare(b.location.country));

				return res;
			}, {});
		},
		getContinentName (code) {
			let cData = CONTINENTS.find(c => c.code === code);

			return cData ? cData.name : null;
		},
		setFilterRule (fIdx) {
			let filtersSet = this.get('filtersSet');
			let availableFilters = this.get('availableFilters');
			let filterRule = availableFilters[fIdx];

			if (filtersSet) {
				filtersSet.push(filterRule);
			} else {
				filtersSet = [ filterRule ];
			}

			filterRule.selected = true;

			this.set('filtersSet', filtersSet);
			this.set('availableFilters', availableFilters);
		},
		rmFilterRule (fIdx) {
			let filtersSet = this.get('filtersSet');
			let availableFilters = this.get('availableFilters');
			let setFilterRule = filtersSet[fIdx];
			let avFiltersRule = availableFilters.find(af => af.value === setFilterRule.value);

			avFiltersRule.selected = false;
			filtersSet.splice(fIdx, 1);

			this.set('filtersSet', filtersSet.length ? filtersSet : null);
			this.set('availableFilters', availableFilters);
		},
		getFilteredProbesList (filtersSet, probesList) {
			let filtered = {};

			filtersSet.forEach((f) => {
				if (f.type === 'byContinent') {
					filtered[f.name] = probesList[f.name];
				}
			});

			return filtered;
		},
	};
</script>
