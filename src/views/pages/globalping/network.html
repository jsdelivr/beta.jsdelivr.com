<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/gp-header.html" name="c-gp-header">
<link rel="ractive" href="../../components/gp-footer.html" name="c-gp-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	{{#if !@shared.isServer && !@shared.googleMapsLoaded}}
		<script>
			function onDocumentReady (fn) {
				if (document.readyState !== 'loading') {
					fn();
				} else {
					document.addEventListener('DOMContentLoaded', fn);
				}
			}
			/* eslint-disable */
			function initMap () {
				onDocumentReady(function () {
					app.loaded = true;

					if (app.router.route && app.router.route.view && app.router.route.view.initMap) {
						app.router.route.view.initMap();
					}
				});
			}
		</script>
		<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBTICLY5LgWNJ0Uly61Q1sNXz_1KZIECwg&amp;language=en&amp;callback=initMap&libraries=marker&loading=async" async></script>
	{{/if}}

	<c-notification></c-notification>

	<c-gp-header additionalClasses="header-with-globalping-bg"></c-gp-header>

	<div class="p-globalping-network">
		<div class="gp-network">
			<div class="gp-network_map-wrapper">
				<div id="gp-map" class="gp-network_map-wrapper_map"></div>
			</div>

			<div class="gp-network_filters">
				<span class="gp-network_filters_title">
					<img width="20" height="20" src="{{@shared.assetsHost}}/img/globalping/filter-icon.svg">
					<span>Filters:</span>
				</span>

				<div class="gp-network_filters_list">
					{{#each filtersSet}}
						<span class="gp-network_filters_list_selected">
							{{this.name}}

							<img on-click="@this.rmFilterRule(@key)"
								width="16"
								height="16"
								src="{{@shared.assetsHost}}/img/globalping/tag-input-close-icon.svg">
						</span>
					{{/each}}

					{{#each availableFilters}}
						{{#unless this.selected}}
							<span on-click="@this.setFilterRule(@key)" class="gp-network_filters_list_item">
								{{this.name}}
							</span>
						{{/unless}}
					{{/each}}
				</div>
			</div>

			<div class="gp-network_list">
				{{#each filteredProbes as probesByContinent}}
					<span class="gp-network_list_item cont-header">{{@this.getContinentName(@key)}}</span>
					{{#each probesByContinent as probesByLocation}}
						<span class="gp-network_list_item">
							<img width="17"
								height="12"
								src="https://cdn.jsdelivr.net/npm/country-flag-icons@1.5.5/3x2/{{probesByLocation[0].location.country}}.svg">

							<span>{{probesByLocation[0].location.country}}, {{probesByLocation[0].location.city}}</span>

							{{#if probesByLocation.length !== 1}}
								<span>(x{{probesByLocation.length}})</span>
							{{/if}}
						</span>
					{{/each}}
				{{/each}}

				{{#if filteredProbes && Object.keys(filteredProbes).length === 0}}
					<div class="gp-network_list_no-result">
						No results found. Try adjusting your filters.
					</div>
				{{/if}}
			</div>
		</div>
	</div>

	<c-gp-footer></c-gp-footer>
</r-page>

<script>
	const debounce = require('../../../assets/js/utils/debounce');
	const throttle = require('../../../assets/js/utils/throttle');
	const has = require('../../../assets/js/utils/has');
	const http = require('../../../assets/js/utils/http');
	const CONTINENTS = require('../../../assets/json/continents.json');
	const MAP_MIN_ZOOM = 2;
	const MAP_MAX_ZOOM = 22;
	const MAP_ZOOM_REG = 3.74;
	const MAP_ZOOM_ALT = 2.14;
	const MAP_CENTER_REG = { lat: 48, lng: 16 };
	const MAP_CENTER_ALT = { lat: 30, lng: 18 };
	const FILTER_TYPE_BY_CONTINENT = 'byContinent';
	const FILTER_TYPE_BY_NETWORK = 'byNetwork';
	const FILTER_TYPE_BY_CLOUD = 'byCloud';
	let map;
	let infoWindows = [];
	let mapMarkers = [];

	component.exports = {
		data () {
			return {
				title: 'Network - Globalping',
				description: 'Network - Globalping',
				availableFilters: [
					{
						name: 'Europe',
						value: 'EU',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'North America',
						value: 'NA',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'South America',
						value: 'SA',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Africa',
						value: 'AF',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Asia',
						value: 'AS',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Oceania',
						value: 'OC',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'eyeball network',
						value: 'eyeball-network',
						type: FILTER_TYPE_BY_NETWORK,
					},
					{
						name: 'datacenter',
						value: 'datacenter-network',
						type: FILTER_TYPE_BY_NETWORK,
					},
					{
						name: 'Google Cloud',
						value: 'gcp',
						type: FILTER_TYPE_BY_CLOUD,
					},
					{
						name: 'AWS Cloud',
						value: 'aws',
						type: FILTER_TYPE_BY_CLOUD,
					},
				],
				filtersSet: null,
				probesResponse: null,
				probesByContinents: null,
				probesByCoords: null,
				filteredProbes: null,
				filteredMarkersData: null,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				// get probes from sessionStorage or fetch them and handle
				this.getProbesData();

				// set initial screenWidth value
				this.observe('screenWidth', (screenWidth) => {
					if (!screenWidth) {
						this.set('screenWidth', innerWidth);
					}
				});

				// sort probes by continents, and each list by country name
				this.observe('probesResponse', (probesResponse) => {
					if (probesResponse) {
						let { groupedByContinents, groupedByCoords } = this.groupProbes(probesResponse);

						this.set('probesByContinents', groupedByContinents);
						this.set('probesByCoords', groupedByCoords);
					}
				});

				// use filters for the probesByContinents before render
				this.observe('filtersSet', (filtersSet) => {
					let filteredProbes = this.getFilteredProbesList(filtersSet);
					let sortedFilteredProbes = this.sortProbesByCountries(filteredProbes);

					this.set('filteredProbes', sortedFilteredProbes);
					this.set('filteredMarkersData', this.getFilteredMarkersData(filtersSet));
				});
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				this.set('@shared.googleMapsLoaded', true);

				if (app.loaded) {
					this.initMap();
				}

				// detect window resize
				window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
			}
		},
		initMap () {
			let mq = window.matchMedia('(min-width: 768px)');

			map = new google.maps.Map(this.find('#gp-map'), {
				zoom: MAP_ZOOM_REG,
				center: MAP_CENTER_REG,
				mapTypeId: 'roadmap',
				draggableCursor: 'default',
				mapTypeControl: false,
				streetViewControl: false,
				fullscreenControl: false,
				minZoom: MAP_MIN_ZOOM,
				maxZoom: MAP_MAX_ZOOM,
				mapId: 'DEMO_MAP_ID', // TODO: 672
			});

			if (mq.matches) {
				map.setCenter(MAP_CENTER_ALT);
				map.setZoom(MAP_ZOOM_ALT);
			}

			this.observe('filteredMarkersData', (markersData, prevMarkersData) => {
				if (markersData && JSON.stringify(markersData) !== JSON.stringify(prevMarkersData)) {
					mapMarkers.forEach(mm => mm.map = null);

					Object.keys(markersData).forEach((key) => {
						let [ lat, lng ] = key.split(', ');

						let marker = mapMarkers.find(mm => mm.position.lat === lat && mm.position.lng === lng);

						if (marker) {
							marker.map = map;
						} else {
							this.createMapMarkerWithIW(key, markersData[key]);
						}
					});
				}
			});

			// close IWs on click on Map
			google.maps.event.addListener(map, 'click', () => {
				infoWindows.forEach(iw => iw.close());
			});
		},
		getProbesData () {
			if (has.sessionStorage()) {
				let probesResponse = sessionStorage.getItem('probesResponse');

				if (probesResponse) {
					this.handleProbesResponse(true)(probesResponse);
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}
			} else {
				http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
			}
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.set('probesResponse', response);
			};
		},
		groupProbes (probes) {
			// group probes by Continents and Coordinates
			return probes.reduce((res, probe) => {
				let coords = `${probe.location.latitude}, ${probe.location.longitude}`;
				let location = `${probe.location.country}, ${probe.location.city}`;

				// group by Continents
				if (!Object.hasOwn(res.groupedByContinents, probe.location.continent)) {
					res.groupedByContinents[probe.location.continent] = {};
				}

				if (!Object.hasOwn(res.groupedByContinents[probe.location.continent], location)) {
					res.groupedByContinents[probe.location.continent][location] = [];
				}

				res.groupedByContinents[probe.location.continent][location].push(probe);

				// group by Coordinates
				if (!Object.hasOwn(res.groupedByCoords, coords)) {
					res.groupedByCoords[coords] = [];
				}

				res.groupedByCoords[coords].push(probe);

				return res;
			}, {
				groupedByContinents: {},
				groupedByCoords: {},
			});
		},
		getContinentName (code) {
			let cData = CONTINENTS.find(c => c.code === code);

			return cData ? cData.name : null;
		},
		setFilterRule (fIdx) {
			let filtersSet = this.get('filtersSet');
			let availableFilters = this.get('availableFilters');
			let filterRule = availableFilters[fIdx];

			filterRule.selected = true;
			filterRule.avFiltersIdx = fIdx;

			if (filtersSet) {
				let isReplaced = false;

				filtersSet = filtersSet.map((fR) => {
					if (fR.type === filterRule.type) {
						isReplaced = true;
						availableFilters[fR.avFiltersIdx].selected = false;

						return filterRule;
					}

					return fR;
				});

				if (!isReplaced) {
					filtersSet.push(filterRule);
				}
			} else {
				filtersSet = [ filterRule ];
			}

			this.set('filtersSet', filtersSet);
			this.set('availableFilters', availableFilters);
		},
		rmFilterRule (fIdx) {
			let filtersSet = this.get('filtersSet');
			let availableFilters = this.get('availableFilters');
			let setFilterRule = filtersSet[fIdx];
			let avFiltersRule = availableFilters.find(af => af.value === setFilterRule.value);

			avFiltersRule.selected = false;
			filtersSet.splice(fIdx, 1);

			this.set('filtersSet', filtersSet.length ? filtersSet : null);
			this.set('availableFilters', availableFilters);
		},
		createMapMarkerWithIW (key, markerData) {
			let infoWindow = new google.maps.InfoWindow();
			let svg = this.createMapMarkerSvg(markerData);
			let [ lat, lng ] = key.split(', ');

			// Collect InfoWindows
			infoWindows.push(infoWindow);
			infoWindow.setContent(this.createInfoWindowContent(markerData));

			let markerContent = document.createElement('div');
			markerContent.style.backgroundImage = `url('data:image/svg+xml;base64,${svg}')`;
			markerContent.style.width = markerData.length === 1 ? '16px' : '24px';
			markerContent.style.height = markerData.length === 1 ? '16px' : '24px';
			markerContent.style.backgroundRepeat = 'no-repeat';
			markerContent.style.backgroundPosition = 'center';
			markerContent.style.backgroundSize = 'contain';

			// Create a new AdvancedMarkerView
			let marker = new google.maps.marker.AdvancedMarkerElement({
				map,
				content: markerContent,
				position: { lat: Number(lat), lng: Number(lng) },
				zIndex: 1,
			});

			// Handle closing of all InfoWindows on a click on a marker
			marker.addListener('click', () => {
				infoWindows.forEach(iw => iw.close());
				infoWindow.open({ map, anchor: marker });
			});

			// Store marker in the array
			mapMarkers.push(marker);
		},
		createMapMarkerSvg (markerData) {
			let number = markerData.length;
			let svgWidth = number === 1 ? 16 : 20;
			let svgHeight = number === 1 ? 16 : 20;
			let circleRadius = number === 1 ? 6 : 8;

			return window.btoa(`<svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" fill="none" xmlns="http://www.w3.org/2000/svg">
				<g filter="url(#filter0_d_6106_3045)">
					<circle cx="${svgWidth / 2}" cy="${svgHeight / 2}" r="${circleRadius}" fill="#17D4A7"/>
					<circle cx="${svgWidth / 2}" cy="${svgHeight / 2}" r="${circleRadius + 1}" stroke="white" stroke-width="2"/>
				</g>
				${number !== 1 ? `<text x="${svgWidth / 2}" y="${svgHeight / 2}" text-anchor="middle" dy=".35em" font-family="Arial" font-size="10" font-weight="bold" fill="#fff">${number}</text>` : ''}
				<defs>
					<filter id="filter0_d_6106_3045" x="0" y="0" width="${svgWidth}" height="${svgHeight}" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
						<feFlood flood-opacity="0" result="BackgroundImageFix"/>
						<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
						<feOffset dy="1"/>
						<feGaussianBlur stdDeviation="1"/>
						<feComposite in2="hardAlpha" operator="out"/>
						<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/>
						<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_6106_3045"/>
						<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_6106_3045" result="shape"/>
					</filter>
				</defs>
			</svg>`);
		},
		createInfoWindowContent (markersByCoords) {
			let markersCnt = markersByCoords.length;
			let groupedNetworks = markersByCoords.reduce((res, m) => {
				let marker = res.find(i => i.location.network === m.location.network);

				if (marker) {
					marker.cnt += 1;
				} else {
					res.push({ ...m, cnt: 1 });
				}

				return res;
			}, []);

			let infoWindowContent = `<div class="gp-network_iw">`;

			if (markersCnt === 1) {
				let { network, city, country } = markersByCoords[0].location;

				infoWindowContent += `<span>${network} (${city}, ${country})</span>`;
			} else {
				// in this case we should render a list of probes
				groupedNetworks.forEach((m, mIdx) => {
					if (mIdx === 0) {
						// add header content
						infoWindowContent += '<span class="gp-network_iw_header">';
						infoWindowContent += `<img width="16" height="16" src="${this.get('@shared.assetsHost')}/img/globalping/location-icon.svg">`;
						infoWindowContent += `<span class="gp-network_iw_header_location">${m.location.city}, ${m.location.country}</span>`;
						infoWindowContent += `<span class="gp-network_iw_header_cnt">${markersByCoords.length}</span>`;
						infoWindowContent += '</span>';
					}

					// render the list of the probes, grouped by the same network
					infoWindowContent += `<span class="gp-network_iw_row">${m.location.network} ${m.cnt > 1 ? `<span class="gp-network_iw_row_network-cnt">${m.cnt}</span>` : ''}</span>`;
				});
			}

			infoWindowContent += '</div>';

			return infoWindowContent;
		},
		getFilteredProbesList (filtersSet) {
			let probesByContinents = this.get('probesByContinents');

			return this.applyFiltersToData(probesByContinents, filtersSet, true);
		},
		getFilteredMarkersData (filtersSet) {
			let probesByCoords = this.get('probesByCoords');

			return this.applyFiltersToData(probesByCoords, filtersSet);
		},
		applyFiltersToData (data, filtersSet, forProbes = false) {
			let filteredProbes = {};

			if (filtersSet === null) {
				return data;
			}

			// get the filter rules
			let byContinentFilerRule = filtersSet.find(fR => fR.type === FILTER_TYPE_BY_CONTINENT);
			let byNetworkFilerRule = filtersSet.find(fR => fR.type === FILTER_TYPE_BY_NETWORK);
			let byCloudFilerRule = filtersSet.find(fR => fR.type === FILTER_TYPE_BY_CLOUD);

			// filter by Continent
			if (byContinentFilerRule) {
				if (forProbes) {
					filteredProbes[byContinentFilerRule.value] = data[byContinentFilerRule.value];
				} else {
					let toFilter = Object.keys(filteredProbes).length ? filteredProbes : data;

					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let filtered = toFilter[key].filter(p => p.location.continent === byContinentFilerRule.value);

						if (filtered.length) {
							res[key] = filtered;
						} else {
							delete res[key];
						}

						return res;
					}, filteredProbes);
				}
			}

			// filter by Network
			if (byNetworkFilerRule) {
				let toFilter = Object.keys(filteredProbes).length ? filteredProbes : data;

				if (forProbes) {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let continentProbes = Object.keys(toFilter[key]).reduce((cRes, loc) => {
							let locFiltered = toFilter[key][loc].filter(p => p.tags.includes(byNetworkFilerRule.value));

							if (locFiltered.length) {
								cRes[loc] = locFiltered;
							}

							return cRes;
						}, {});

						if (Object.keys(continentProbes).length) {
							res[key] = continentProbes;
						} else {
							delete res[key];
						}

						return res;
					}, {});
				} else {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let filtered = toFilter[key].filter(p => p.tags.includes(byNetworkFilerRule.value));

						if (filtered.length) {
							res[key] = filtered;
						} else {
							delete res[key];
						}

						return res;
					}, filteredProbes);
				}
			}

			// filter by Cloud provider
			if (byCloudFilerRule) {
				let toFilter = Object.keys(filteredProbes).length ? filteredProbes : data;

				if (forProbes) {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let continentProbes = Object.keys(toFilter[key]).reduce((cRes, loc) => {
							let locFiltered = toFilter[key][loc].filter(p => p.tags.some(v => v.startsWith(byCloudFilerRule.value)));

							if (locFiltered.length) {
								cRes[loc] = locFiltered;
							}

							return cRes;
						}, {});

						if (Object.keys(continentProbes).length) {
							res[key] = continentProbes;
						} else {
							delete res[key];
						}

						return res;
					}, {});
				} else {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let filtered = toFilter[key].filter(p => p.tags.some(v => v.startsWith(byCloudFilerRule.value)));

						if (filtered.length) {
							res[key] = filtered;
						} else {
							delete res[key];
						}

						return res;
					}, filteredProbes);
				}
			}

			return filteredProbes;
		},
		sortProbesByCountries (obj) {
			let sortedObj = {};

			// iterate over Continent keys
			Object.keys(obj).forEach((continent) => {
				// sort the keys based on the country code
				let sortedLocations = Object.keys(obj[continent]).sort((a, b) => {
					let countryA = a.split(', ')[0];
					let countryB = b.split(', ')[0];

					return countryA.localeCompare(countryB);
				});

				sortedObj[continent] = {};

				sortedLocations.forEach((location) => {
					sortedObj[continent][location] = obj[continent][location];
				});
			});

			return sortedObj;
		},
	};
</script>
