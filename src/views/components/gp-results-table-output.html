<link rel="ractive" href="../components/gp-results-share.html" name="c-gp-results-share">

<div class="c-gp-results-table-output">
	<div class="results-table {{#if targetsCnt === 1}}single-target{{/if}}">
		<div class="results-table_column_header">Location</div>

		{{#if targetsCnt > 1}}
			<div class="results-table_column_header"></div>
		{{/if}}

		<div class="results-table_column_header">Quality</div>
		<div class="results-table_column_header">rtt min /avg / max</div>
		<div class="results-table_column_header">IP</div>
		<div class="results-table_column_header">Graph</div>

		{{#each preparedTestResults:resIdx}}
			<div class="results-table_column_location row-num-{{resIdx}}">
				<span class="results-table_column_location_status-line"></span>

				<img width="28" height="20" src="https://cdn.jsdelivr.net/npm/country-flag-icons@1.5.5/3x2/{{this.country}}.svg">

				<div>
					<span>{{this.city}}, {{this.country}}, {{this.continent}}</span>
					<span>{{this.network}}</span>
				</div>
			</div>

			{{#if targetsCnt > 1}}
				<div class="results-table_column_urls">
					{{#each this.probesData}}
						<div class="results-table_column_urls_value {{#if preparedTestResults[resIdx].probesData.length === 1}}single-cell{{/if}}">
							<span>{{this.target}}</span>
						</div>
					{{/each}}
				</div>
			{{/if}}

			<div class="results-table_column_quality">
				{{#each this.probesData}}
					<div class="results-table_column_quality_value {{#if preparedTestResults[resIdx].probesData.length === 1}}single-cell{{/if}}">
						<span class="results-table_column_quality_value_header">Quality</span>
						<span>
							{{this.statsTotal - this.statsLoss}} /{{this.statsTotal}} - {{Math.round((this.statsTotal - this.statsLoss)/this.statsTotal * 100)}}%
						</span>
					</div>
				{{/each}}
			</div>

			<div class="results-table_column_rtt">
				{{#each this.probesData}}
					<div class="results-table_column_rtt_value {{#if preparedTestResults[resIdx].probesData.length === 1}}single-cell{{/if}}">
						<span class="results-table_column_rtt_value_header">rtt min / avg / max</span>
						<span>{{this.minTimings}} / {{this.avgTimings}} / {{this.maxTimings}} ms</span>
					</div>
				{{/each}}
			</div>

			<div class="results-table_column_ip">
				{{#each this.probesData}}
					<div class="results-table_column_ip_value {{#if preparedTestResults[resIdx].probesData.length === 1}}single-cell{{/if}}">
						<span class="results-table_column_ip_value_header">IP</span>
						<span>{{this.ipAddr}}</span>
					</div>
				{{/each}}
			</div>

			<div class="results-table_column_graph">
				{{#each this.probesData}}
					<div class="results-table_column_graph_value {{#if preparedTestResults[resIdx].probesData.length === 1}}single-cell{{/if}}">
						<span class="results-table_column_graph_value_header">Graph</span>
						<img width="48" height="24" src="{{@shared.assetsHost}}/img/globalping/TEMP.graph.svg">
					</div>
				{{/each}}
			</div>

			<div class="results-table_line"></div>
		{{/each}}
	</div>

	{{#if testReqParams.id && !testInProgress}}
		<c-gp-results-share testReqParams="{{testReqParams}}"></c-gp-results-share>
	{{/if}}
</div>

<script>

component.exports = {
	data () {
		return {
			preparedTestResults: [],
		};
	},
	oninit () {
		if (!Ractive.isServer) {
			this.observe('testResults', (testResults) => {
				this.set('preparedTestResults', this.combineResults(testResults));
			});
		}
	},
	combineResults (results) {
		return results.reduce((prepResults, resArr, resArrIdx) => {
			if (resArrIdx === 0) {
				return resArr.map((res) => ({
					clientSideId: res.clientSideId,
					...res.probe,
					probesData: [{
						target: res.target,
						ipAddr: res.result.resolvedAddress,
						minTimings: res.result.stats.min,
						avgTimings: res.result.stats.avg,
						maxTimings: res.result.stats.max,
						statsTotal: res.result.stats.total,
						statsLoss: res.result.stats.loss,
					}],
				}));
			} else {
				return prepResults.map((pR) => {
					let nextReqRes = resArr.find(rA => rA.clientSideId === pR.clientSideId);

					if (nextReqRes) {
						return {
							...pR,
							probesData: [
								...pR.probesData,
								{
									target: nextReqRes.target,
									ipAddr: nextReqRes.result.resolvedAddress,
									minTimings: nextReqRes.result.stats.min,
									avgTimings: nextReqRes.result.stats.avg,
									maxTimings: nextReqRes.result.stats.max,
									statsTotal: nextReqRes.result.stats.total,
									statsLoss: nextReqRes.result.stats.loss,
								},
							],
						};
					}

					return pR;
				});
			}

			return prepResults;
		}, []);
	},
};
</script>
