<link rel="ractive" href="../components/gp-results-share.html" name="c-gp-results-share">

<div class="c-gp-results-table-output">
	<div class="results-table-wrapper">
		<div class="results-table {{#if targetsCnt === 1}}single-target{{/if}}">
			<div class="results-table_column_header">Location</div>

			{{#if targetsCnt > 1}}
				<div class="results-table_column_header"></div>
			{{/if}}

			<div class="results-table_column_header">Quality</div>
			<div class="results-table_column_header">rtt last / min / avg / max</div>
			<div class="results-table_column_header">IP</div>
			<div class="results-table_column_header">Graph</div>

			{{#each preparedTestResults:resIdx}}
				<div class="results-table_column results-table_column_location row-num-{{resIdx}}">
					<span class="results-table_column_location_status-line {{@this.getStatusLineColorClass(this)}}"></span>

					<img width="28" height="20" src="https://cdn.jsdelivr.net/npm/country-flag-icons@1.5.5/3x2/{{this.country}}.svg">

					<div class="results-table_column_location_data">
						<span>{{this.city}}, {{this.country}}, {{this.continent}}</span>
						<span>{{this.network}}</span>
					</div>

					<div class="results-table_column_location_actions">
						<div class="results-table_column_location_actions_btn"
							as-tooltip="'Set as location for the next test', 'right'"
							on-click="@this.setProbeAsLocation(this)">
							<i class="fa fa-map-marker" aria-hidden="true"></i>
						</div>
					</div>
				</div>

				{{#if targetsCnt > 1}}
					<div class="results-table_column results-table_column_urls row-num-{{resIdx}}">
						{{#each this.statsPerProbes}}
							<div class="results-table_column_urls_value {{#if preparedTestResults[resIdx].statsPerProbes.length === 1}}single-cell{{/if}}">
								<span>{{this.target}}</span>
							</div>
						{{/each}}
					</div>
				{{/if}}

				<div class="results-table_column results-table_column_quality row-num-{{resIdx}}">
					{{#each this.statsPerProbes}}
						<div class="results-table_column_quality_value {{#if preparedTestResults[resIdx].statsPerProbes.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_quality_value_header">Quality</span>
							<span>
								{{this.statsTotal - this.statsLoss}} /{{this.statsTotal}} - {{Math.round((this.statsTotal - this.statsLoss)/this.statsTotal * 100)}}%
							</span>
						</div>
					{{/each}}
				</div>

				<div class="results-table_column results-table_column_rtt row-num-{{resIdx}}">
					{{#each this.statsPerProbes}}
						<div class="results-table_column_rtt_value {{#if preparedTestResults[resIdx].statsPerProbes.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_rtt_value_header">rtt last / min / avg / max</span>
							<span>{{this.lastTiming}} / {{this.minTiming}} / {{this.avgTiming}} / {{this.maxTiming}} ms</span>
						</div>
					{{/each}}
				</div>

				<div class="results-table_column results-table_column_ip row-num-{{resIdx}}">
					{{#each this.statsPerProbes}}
						<div class="results-table_column_ip_value {{#if preparedTestResults[resIdx].statsPerProbes.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_ip_value_header">IP</span>
							<span>{{this.ipAddr}}</span>
						</div>
					{{/each}}
				</div>

				<div class="results-table_column results-table_column_graph row-num-{{resIdx}}">
					{{#each this.statsPerProbes}}
						<div class="results-table_column_graph_value {{#if preparedTestResults[resIdx].statsPerProbes.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_graph_value_header">Graph</span>
							<img width="48" height="24" src="{{@shared.assetsHost}}/img/globalping/TEMP.graph.svg">
						</div>
					{{/each}}
				</div>

				<div class="results-table_line"></div>
			{{/each}}
		</div>
	</div>

	{{#if testReqParams.id && !testInProgress}}
		<c-gp-results-share
			testReqParams="{{testReqParams}}"
			measurementsMetadata="{{measurementsMetadata}}">
		</c-gp-results-share>
	{{/if}}
</div>

<script>
	const _ = require('../../assets/js/_');
	const tooltip = require('../../assets/js/decorators/tooltip');

	component.exports = {
		decorators: {
			tooltip,
		},
		data () {
			return {
				preparedTestResults: [],
				displayedRowsCnt: null,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('testResults', (testResults) => {
					let testType = this.get('testReqParams.type');
					let infiniteMeasurement = this.get('infiniteMeasurement');
					let preparedTestResults;

					if (testType === 'ping' && infiniteMeasurement) {
						preparedTestResults = this.combineInfiniteResults(testResults);
					} else {
						preparedTestResults = this.combineResults(testResults);
					}

					this.set('preparedTestResults', preparedTestResults);
				});
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				this.observe('preparedTestResults', (preparedTestResults, prevValue = []) => {
					// set results block height based on content
					this.setResultsBlockHeight(preparedTestResults);
					this.handleProbeRowActionBtn(prevValue.length);
				});
			}
		},
		oncomplete () {
			if (!Ractive.isServer) {
				let tableEl = this.find('.c-gp-results-table-output .results-table');
				let allActionBtnsElements = tableEl.querySelectorAll('.results-table_column_location .results-table_column_location_actions_btn');

				tableEl.addEventListener('mouseleave', () => {
					allActionBtnsElements.forEach(el => el.style.visibility = 'hidden');
				});
			}
		},
		combineResults (results) {
			return results.reduce((prepResults, resArr, resArrIdx) => {
				let dnsTraceEnabled = this.get('testReqParams.measurementOptions.trace');

				if (resArrIdx === 0) {
					return resArr.map((res) => {
						let { isFailed = false } = _.calcGpTestResTiming(res.type, res, dnsTraceEnabled);

						// TODO: 592, handle timing values for time-out/failed cases
						// TODO: 592, check the stats/last timings for other types of meaurement, since a
						// TODO: 592 lot of them have no timings or stats, but have hops, so should be handled defferently
						return {
							clientSideId: res.clientSideId,
							...res.probe,
							statsPerProbes: [{
								target: res.target,
								ipAddr: res.result.resolvedAddress,
								lastTiming: res.result.timings[res.result.timings.length - 1].rtt,
								minTiming: res.result.stats.min,
								avgTiming: res.result.stats.avg,
								maxTiming: res.result.stats.max,
								statsTotal: res.result.stats.total,
								statsLoss: res.result.stats.loss,
								isFailed,
							}],
						};
					});
				}

				return prepResults.map((pR) => {
					let nextReqRes = resArr.find(rA => rA.clientSideId === pR.clientSideId);

					if (nextReqRes) {
						let { isFailed = false } = _.calcGpTestResTiming(nextReqRes.type, nextReqRes, dnsTraceEnabled);

						// TODO: 592, handle timing values for time-out/failed cases
						// TODO: 592, check the stats/last timings for other types of meaurement, since a
						// TODO: 592 lot of them have no timings or stats, but have hops, so should be handled defferently
						return {
							...pR,
							statsPerProbes: [
								...pR.statsPerProbes,
								{
									target: nextReqRes.target,
									ipAddr: nextReqRes.result.resolvedAddress,
									lastTiming: nextReqRes.result.timings[nextReqRes.result.timings.length - 1] ? nextReqRes.result.timings[nextReqRes.result.timings.length - 1].rtt : 0,
									minTiming: nextReqRes.result.stats.min,
									avgTiming: nextReqRes.result.stats.avg,
									maxTiming: nextReqRes.result.stats.max,
									statsTotal: nextReqRes.result.stats.total,
									statsLoss: nextReqRes.result.stats.loss,
									isFailed,
								},
							],
						};
					}

					return pR;
				});
			}, []);
		},
		setProbeAsLocation (probeData) {
			this.set('currSearchLocation', `AS${probeData.asn}+${probeData.city}`);
		},
		setResultsBlockHeight (results) {
			requestAnimationFrame(() => {
				let listWrapperEl = document.querySelector('.results-table-wrapper');
				let itemsAmount = results.length;
				let listElScrollHeight = listWrapperEl.scrollHeight;
				let avgItemElHeight = Math.round(listElScrollHeight / itemsAmount);

				listWrapperEl.style.height = `${itemsAmount < 8 ? avgItemElHeight * itemsAmount : avgItemElHeight * 8}px`;
			});
		},
		getStatusLineColorClass (probesData) {
			if (probesData.statsPerProbes.every(s => s.isFailed === false)) {
				return 'success';
			} else if (probesData.statsPerProbes.every(s => s.isFailed === true)) {
				return 'failed';
			}

			return 'some-failed';
		},
		combineInfiniteResults (results) {
			return results.reduce((prepRes, resArr, resArIdx) => {
				let dnsTraceEnabled = this.get('testReqParams.measurementOptions.trace');
				let res = resArr[0];// TODO: 592, temp, here results should be combined too
				let { isFailed = false } = _.calcGpTestResTiming(res.type, res, dnsTraceEnabled);

				prepRes.push({
					clientSideId: resArIdx,
					...res.probe,
					statsPerProbes: [{
						target: res.target,
						ipAddr: res.result.resolvedAddress,
						// lastTiming: res.result.timings[res.result.timings.length - 1].rtt,
						lastTiming: 0,
						minTiming: res.result.stats ? res.result.stats.min : 0,
						avgTiming: res.result.stats ? res.result.stats.avg : 0,
						maxTiming: res.result.stats ? res.result.stats.max : 0,
						statsTotal: res.result.stats ? res.result.stats.total : 0,
						statsLoss: res.result.stats ? res.result.stats.loss : 0,
						isFailed,
					}],
				});

				return prepRes;
			}, []);
		},
		handleProbeRowActionBtn (rowIdx) {
			let displayedRowsCnt = this.get('displayedRowsCnt');

			if (displayedRowsCnt && displayedRowsCnt === rowIdx) {
				return;
			}

			let intervalId = setInterval(() => {
				let tableEl = document.querySelector('.c-gp-results-table-output .results-table');
				let cells = tableEl.querySelectorAll(`.results-table_column.row-num-${rowIdx}`);
				let actionEl = tableEl.querySelector(`.results-table_column.row-num-${rowIdx} .results-table_column_location_actions_btn`);

				if (!tableEl || !cells || !cells.length || !actionEl) {
					return;
				}

				clearInterval(intervalId);

				cells.forEach((c) => {
					c.addEventListener('mouseover', (e) => {
						let allActionBtnsElements = tableEl.querySelectorAll('.results-table_column_location .results-table_column_location_actions_btn');

						allActionBtnsElements.forEach(el => el.style.visibility = 'hidden');
						actionEl.style.visibility = 'visible';
					});
				});

				tableEl.addEventListener('mouseleave', () => {
					let allActionBtnsElements = tableEl.querySelectorAll('.results-table_column_location .results-table_column_location_actions_btn');

					allActionBtnsElements.forEach(el => el.style.visibility = 'hidden');
				});

				this.set('displayedRowsCnt', rowIdx);
			}, 4);
		},
	};
</script>
