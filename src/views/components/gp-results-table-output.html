<link rel="ractive" href="../components/gp-results-share.html" name="c-gp-results-share">
<link rel="ractive" href="../components/placeholder-skeleton.html" name="c-placeholder-skeleton">

<div class="c-gp-results-table-output">
	<div class="results-table-wrapper">
		<div class="results-table {{#if targetsCnt === 1}}single-target{{/if}}">
			<div class="results-table_column_header">Location</div>

			{{#if targetsCnt > 1}}
				<div class="results-table_column_header"></div>
			{{/if}}

			<div class="results-table_column_header">Quality</div>
			<div class="results-table_column_header">rtt last / min / avg / max</div>
			<div class="results-table_column_header">IP</div>
			<div class="results-table_column_header">Graph</div>

			{{#each preparedTestResults:resIdx}}
				<div class="results-table_column results-table_column_location row-num-{{resIdx}}">
					<span class="results-table_column_location_status-line {{@this.getStatusLineColorClass(this)}}"></span>

					<img width="28" height="20" src="https://cdn.jsdelivr.net/npm/country-flag-icons@1.5.5/3x2/{{this.country}}.svg">

					<div class="results-table_column_location_data">
						<span>{{this.city}}, {{this.country}}, {{this.continent}}</span>
						<span>{{this.network}}</span>
					</div>

					<div class="results-table_column_location_actions">
						<div class="results-table_column_location_actions_btn"
							as-tooltip="'Set as location for the next test', 'right'"
							on-click="@this.setProbeAsLocation(this)">
							<i class="fa fa-map-marker" aria-hidden="true"></i>
						</div>
					</div>
				</div>

				{{#if targetsCnt > 1}}
					<div class="results-table_column results-table_column_urls row-num-{{resIdx}}">
						{{#each this.statsPerTarget}}
							<div class="results-table_column_urls_value {{#if preparedTestResults[resIdx].statsPerTarget.length === 1}}single-cell{{/if}}">
								{{#if this.target}}
									<span>{{this.target}}</span>
								{{else}}
									<c-placeholder-skeleton type="subheader"></c-placeholder-skeleton>
								{{/if}}
							</div>
						{{/each}}
					</div>
				{{/if}}

				<div class="results-table_column results-table_column_quality row-num-{{resIdx}}">
					{{#each this.statsPerTarget}}
						<div class="results-table_column_quality_value {{#if preparedTestResults[resIdx].statsPerTarget.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_quality_value_header">Quality</span>
							{{#if this.qualityStr}}
								<span>{{this.qualityStr}}</span>
							{{else}}
								<c-placeholder-skeleton type="subheader"></c-placeholder-skeleton>
							{{/if}}
						</div>
					{{/each}}
				</div>

				<div class="results-table_column results-table_column_rtt row-num-{{resIdx}}">
					{{#each this.statsPerTarget}}
						<div class="results-table_column_rtt_value {{#if preparedTestResults[resIdx].statsPerTarget.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_rtt_value_header">rtt last / min / avg / max</span>
							{{#if this.timingsStr}}
								<span>{{this.timingsStr}}</span>
							{{elseif !this.timingStr && !this.isFailed && !this.isOffline}}
								<c-placeholder-skeleton type="subheader"></c-placeholder-skeleton>
							{{/if}}
						</div>
					{{/each}}
				</div>

				<div class="results-table_column results-table_column_ip row-num-{{resIdx}}">
					{{#each this.statsPerTarget}}
						<div class="results-table_column_ip_value {{#if preparedTestResults[resIdx].statsPerTarget.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_ip_value_header">IP</span>
							{{#if this.ipAddr}}
								<span>{{this.ipAddr}}</span>
							{{elseif !this.ipAddr && !this.isFailed && !this.isOffline}}
								<c-placeholder-skeleton type="subheader"></c-placeholder-skeleton>
							{{/if}}
						</div>
					{{/each}}
				</div>

				<div class="results-table_column results-table_column_graph row-num-{{resIdx}}">
					{{#each this.statsPerTarget}}
						<div class="results-table_column_graph_value {{#if preparedTestResults[resIdx].statsPerTarget.length === 1}}single-cell{{/if}}">
							<span class="results-table_column_graph_value_header">Graph</span>
							{{#if typeof this.packetsRtt !== 'undefined'}}
								<div>{{{ @this.createGraph(this.packetsRtt) }}}</div>
							{{else}}
								<c-placeholder-skeleton type="subheader"></c-placeholder-skeleton>
							{{/if}}
						</div>
					{{/each}}
				</div>

				<div class="results-table_line"></div>
			{{/each}}
		</div>
	</div>

	{{#if testReqParams.id && !testInProgress}}
		<c-gp-results-share
			testReqParams="{{testReqParams}}"
			measurementsMetadata="{{measurementsMetadata}}"
			isInfiniteModeRes="{{isInfiniteModeRes}}"
			testInProgress="{{testInProgress}}">
		</c-gp-results-share>
	{{/if}}
</div>

<script>
	const _ = require('../../assets/js/_');
	const tooltip = require('../../assets/js/decorators/tooltip');
	const PROBE_MAX_TIMING = 200;
	const PROBE_MIN_TIMING = 5;
	const PROBE_NO_TIMING_VALUE = _.getProbeTimeOutValue();
	const PROBE_STATUS_FAILED = _.getProbeStatusFailedValue();
	const PROBE_STATUS_OFFLINE = _.getProbeStatusOfflineValue();

	component.exports = {
		decorators: {
			tooltip,
		},
		data () {
			return {
				preparedTestResults: [],
				displayedRowsIdxes: [],
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('testResults', (testResults) => {
					if (!testResults) { return; }

					let testType = this.get('testReqParams.type');
					let isInfiniteModeRes = this.get('isInfiniteModeRes');
					let updPreparedTestResults;

					if (testType === 'ping' && isInfiniteModeRes) {
						updPreparedTestResults = this.combineInfiniteResults(testResults);
					} else {
						updPreparedTestResults = this.combineRegularResults(testResults);
					}

					this.set('preparedTestResults', updPreparedTestResults);
				});
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				this.observe('preparedTestResults', (preparedTestResults) => {
					// set results block height based on content
					this.setResultsBlockHeight(preparedTestResults);
					preparedTestResults.forEach((r, rIdx) => this.handleProbeRowActionBtn(rIdx));
				});
			}
		},
		oncomplete () {
			if (!Ractive.isServer) {
				let tableEl = this.find('.c-gp-results-table-output .results-table');
				let allActionBtnsElements = tableEl.querySelectorAll('.results-table_column_location .results-table_column_location_actions_btn');

				tableEl.addEventListener('mouseleave', () => {
					allActionBtnsElements.forEach(el => el.style.visibility = 'hidden');
				});
			}
		},
		combineRegularResults (results) {
			return results.reduce((prepResults, resArr, resArrIdx) => {
				let dnsTraceEnabled = this.get('testReqParams.measurementOptions.trace');

				if (resArrIdx === 0) {
					return resArr.map((res) => {
						let preparedRes = {
							clientSideId: res.clientSideId,
							...res.probe,
							statsPerTarget: [{
								target: res.target,
							}],
						};

						if (res.result.status !== 'in-progress') {
							let { isFailed = false, lastTiming, value: avgTiming } = _.calcGpTestResTiming(res.type, res, dnsTraceEnabled);
							let { packetsRtt } = _.parseGpRawOutputForTimings(res.result.rawOutput);
							let minTiming = res.result?.stats?.min || PROBE_NO_TIMING_VALUE;
							let maxTiming = res.result?.stats?.max || PROBE_NO_TIMING_VALUE;
							let statsTotal = res.result?.stats?.total;
							let statsDrop = res.result?.stats?.drop;
							let isOffline = res.result.status === PROBE_STATUS_OFFLINE;

							preparedRes.statsPerTarget = [{
								...preparedRes.statsPerTarget[0],
								ipAddr: res.result.resolvedAddress,
								lastTiming,
								minTiming,
								avgTiming,
								maxTiming,
								statsTotal,
								statsDrop,
								isFailed,
								isOffline,
								packetsRtt,
								qualityStr: this.createQualityString(isOffline, statsTotal, statsDrop),
								timingsStr: this.createTimingsString(lastTiming, maxTiming, minTiming, avgTiming),
							}];
						}

						return preparedRes;
					});
				}

				return prepResults.map((pR) => {
					let nextReqRes = resArr.find(rA => rA.clientSideId === pR.clientSideId);

					if (nextReqRes) {
						let preparedNextRes = {
							...pR,
							statsPerTarget: [
								...pR.statsPerTarget,
								{
									target: nextReqRes.target,
								},
							],
						};

						if (nextReqRes.result.status !== 'in-progress') {
							let { isFailed = false, lastTiming, value: avgTiming } = _.calcGpTestResTiming(nextReqRes.type, nextReqRes, dnsTraceEnabled);
							let { packetsRtt } = _.parseGpRawOutputForTimings(nextReqRes.result.rawOutput);
							let minTiming = nextReqRes.result?.stats?.min || PROBE_NO_TIMING_VALUE;
							let maxTiming = nextReqRes.result?.stats?.max || PROBE_NO_TIMING_VALUE;
							let statsTotal = nextReqRes.result?.stats?.total;
							let statsDrop = nextReqRes.result?.stats?.drop;
							let isOffline = nextReqRes.result.status === PROBE_STATUS_OFFLINE;

							preparedNextRes.statsPerTarget = [
								...pR.statsPerTarget,
								{
									...preparedNextRes.statsPerTarget[1],
									ipAddr: nextReqRes.result.resolvedAddress,
									lastTiming,
									minTiming,
									avgTiming,
									maxTiming,
									statsTotal,
									statsDrop,
									isFailed,
									isOffline,
									packetsRtt,
									qualityStr: this.createQualityString(isOffline, statsTotal, statsDrop),
									timingsStr: this.createTimingsString(lastTiming, maxTiming, minTiming, avgTiming),
								},
							];
						}

						return preparedNextRes;
					}

					return pR;
				});
			}, []);
		},
		setProbeAsLocation (probeData) {
			this.set('currSearchLocation', `AS${probeData.asn}+${probeData.city}`);
		},
		setResultsBlockHeight (results) {
			requestAnimationFrame(() => {
				let listWrapperEl = document.querySelector('.results-table-wrapper');
				let itemsAmount = results.length;
				let listElScrollHeight = listWrapperEl.scrollHeight;
				let avgItemElHeight = Math.round(listElScrollHeight / itemsAmount);

				listWrapperEl.style.height = `${itemsAmount < 8 ? avgItemElHeight * itemsAmount : avgItemElHeight * 8}px`;
			});
		},
		getStatusLineColorClass (probesData) {
			if (!probesData) { return; }

			let { statsTotal, statsDrop } = probesData.statsPerTarget[0];
			let { qualityPercentage } = this.calcQuality(statsTotal, statsDrop);

			if (qualityPercentage === null) {
				return '';
			} else if (qualityPercentage === 100) {
				return 'success';
			} else if (qualityPercentage === 0) {
				return 'failure';
			}

			return 'some-issues';
		},
		combineInfiniteResults (rawResults) {
			let preparedTestResults = this.get('preparedTestResults');

			return rawResults.reduce((prepResultsObj, rawRes) => {
				rawRes.forEach((probeData, probeDataIdx) => {
					let {
						parsedData: prevParsedData = {
							keyOrder: [],
							packetsRttData: {},
							packetsDropData: {},
							ipAddr: null,
						},
					} = prepResultsObj[probeDataIdx] ? prepResultsObj[probeDataIdx].statsPerTarget[0] : {};
					let currIpAddr = prevParsedData.ipAddr || this.parseIPFromRawOutput(probeData.result.rawOutput);
					let { packetsRtt: currPacketsRtt, packetsDrop: currPacketsDrop } = _.parseGpRawOutputForTimings(probeData.result.rawOutput);
					let { finalPacketsRtt, finalPacketsDrop } = prevParsedData.keyOrder.reduce((final, key) => {
						return {
							finalPacketsRtt: [ ...final.finalPacketsRtt, ...prevParsedData.packetsRttData[key] ],
							finalPacketsDrop: final.finalPacketsDrop + prevParsedData.packetsDropData[key],
						};
					}, { finalPacketsRtt: [], finalPacketsDrop: 0 });
					let updKeyOrder = prevParsedData.keyOrder.includes(probeData.id) ? prevParsedData.keyOrder : [ ...prevParsedData.keyOrder, probeData.id ];
					let realPacketsRttValues = finalPacketsRtt.filter(v => typeof v === 'number');
					let currMaxValue = realPacketsRttValues.length ? Math.max(...realPacketsRttValues) : PROBE_NO_TIMING_VALUE;
					let currMinValue = realPacketsRttValues.length ? Math.min(...realPacketsRttValues) : PROBE_NO_TIMING_VALUE;
					let calcAvgTiming = realPacketsRttValues.length
						? (realPacketsRttValues.reduce((res, rtt) => res += rtt, 0) / realPacketsRttValues.length).toFixed(2)
						: PROBE_NO_TIMING_VALUE;

					prepResultsObj[probeDataIdx] = {
						clientSideId: probeDataIdx,
						...probeData.probe,
						statsPerTarget: [{
							target: probeData.target,
							ipAddr: currIpAddr,
							lastTiming: finalPacketsRtt[finalPacketsRtt.length - 1],
							minTiming: currMinValue,
							avgTiming: calcAvgTiming,
							maxTiming: currMaxValue,
							statsTotal: finalPacketsRtt.length,
							statsDrop: finalPacketsDrop,
							isFailed: probeData.result.status === PROBE_STATUS_FAILED,
							isOffline: probeData.result.status === PROBE_STATUS_OFFLINE,
							failureRawOutput: this.getFailureProbeRawOutput(probeData),
							packetsRtt: finalPacketsRtt,
							qualityStr: this.createQualityString(
								probeData.result.status === PROBE_STATUS_OFFLINE,
								realPacketsRttValues.length + finalPacketsDrop,
								finalPacketsDrop,
							),
							timingsStr: this.createTimingsString(
								realPacketsRttValues[realPacketsRttValues.length - 1],
								currMaxValue,
								currMinValue,
								calcAvgTiming,
							),
							parsedData: {
								keyOrder: updKeyOrder,
								packetsRttData: {
									...prevParsedData.packetsRttData,
									[probeData.id]: currPacketsRtt,
								},
								packetsDropData: {
									...prevParsedData.packetsDropData,
									[probeData.id]: currPacketsDrop,
								},
								ipAddr: currIpAddr,
							},
						}],
					};
				});

				return prepResultsObj;
			}, preparedTestResults);
		},
		handleProbeRowActionBtn (rowIdx) {
			let displayedRowsIdxes = this.get('displayedRowsIdxes');

			if (displayedRowsIdxes.includes(rowIdx)) {
				return;
			}

			let intervalId = setInterval(() => {
				let tableEl = document.querySelector('.c-gp-results-table-output .results-table');

				if (!tableEl) {
					return;
				}

				let cells = tableEl.querySelectorAll(`.results-table_column.row-num-${rowIdx}`);
				let actionEl = tableEl.querySelector(`.results-table_column.row-num-${rowIdx} .results-table_column_location_actions_btn`);

				if (!cells || !cells.length || !actionEl) {
					return;
				}

				clearInterval(intervalId);

				cells.forEach((c) => {
					c.addEventListener('mouseover', () => {
						let allActionBtnsElements = tableEl.querySelectorAll('.results-table_column_location .results-table_column_location_actions_btn');

						allActionBtnsElements.forEach(el => el.style.visibility = 'hidden');
						actionEl.style.visibility = 'visible';
					});
				});

				tableEl.addEventListener('mouseleave', () => {
					let allActionBtnsElements = tableEl.querySelectorAll('.results-table_column_location .results-table_column_location_actions_btn');

					allActionBtnsElements.forEach(el => el.style.visibility = 'hidden');
				});

				this.push('displayedRowsIdxes', rowIdx);
			}, 4);
		},
		getAvgTimingValueToDisplay (timing) {
			// for infinite results timing is an array of avg timing values
			if (Array.isArray(timing)) {
				let sum = timing.reduce((sum, t) => sum + t, 0);

				return Math.round(sum / timing.length * 100) / 100;
			}

			return timing;
		},
		createRealTimeGraph (
			data,
			svgWidth = 48,
			svgHeight = 24,
			svgBgColor = '#F4F4F4',
			barWidth = 2,
			gap = 1,
		) {
			if (!data) { return; }

			let maxValue = Math.max(...data.filter(v => typeof v === 'number'));
			let maxBars = Math.floor(svgWidth / (barWidth + gap));
			let startIndex = Math.max(data.length - maxBars, 0);
			let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

			svg.setAttribute('width', svgWidth);
			svg.setAttribute('height', svgHeight);
			svg.style.backgroundColor = svgBgColor;

			for (let i = startIndex; i < data.length; i++) {
				let percentage = data[i] === maxValue || data[i] === PROBE_NO_TIMING_VALUE ? 1 : data[i] / maxValue;
				let barHeight = percentage * svgHeight;

				let x = svgWidth - ((data.length - 1 - i) * (barWidth + gap)) - barWidth;
				let y = svgHeight - barHeight;

				if (x >= 0) {
					let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

					rect.setAttribute('x', x);
					rect.setAttribute('y', y);
					rect.setAttribute('width', barWidth);
					rect.setAttribute('height', barHeight);
					rect.setAttribute('fill', this.pickBarColor(data[i]));
					svg.appendChild(rect);
				}
			}

			return svg.outerHTML;
		},
		createRegularGraph (
			data,
			svgWidth = 48,
			svgHeight = 24,
			svgBgColor = '#F4F4F4',
		) {
			if (!data || data.length === 0) { return; }

			data = data.slice(-20);

			let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			let numBars = data.length;
			let spaceWidth = 1;
			let barWidth = Math.round(svgWidth / numBars - spaceWidth);
			let maxValue = Math.max(...data.filter(v => typeof v === 'number'));
			let actualWidth = barWidth * numBars + (numBars - 1) * spaceWidth;

			svg.setAttribute('width', actualWidth > svgWidth ? actualWidth : svgWidth);
			svg.setAttribute('height', svgHeight);
			svg.style.backgroundColor = svgBgColor;

			data.forEach((value, index) => {
				let barHeight = value === PROBE_NO_TIMING_VALUE ? svgHeight : (value / maxValue) * svgHeight;
				let xPosition = index * spaceWidth + index * barWidth;
				let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

				rect.setAttribute('x', xPosition);
				rect.setAttribute('y', svgHeight - barHeight);
				rect.setAttribute('width', barWidth);
				rect.setAttribute('height', barHeight);
				rect.setAttribute('fill', this.pickBarColor(value));
				svg.appendChild(rect);
			});

			return svg.outerHTML;
		},
		pickBarColor (timing) {
			// return default color for timed out probe
			if (timing === PROBE_NO_TIMING_VALUE) {
				return '#17233A';
			}

			function getColorFromGradient (quotient, start, middle, end) {
				return quotient >= 0.5 ? linear(middle, end, (quotient - 0.5) * 2) : linear(start, middle, quotient * 2);
			}

			function linear (startColor, endColor, quotient) {
				let redColor = byteLinear(startColor[1] + startColor[2], endColor[1] + endColor[2], quotient);
				let greenColor = byteLinear(startColor[3] + startColor[4], endColor[3] + endColor[4], quotient);
				let blueColor = byteLinear(startColor[5] + startColor[6], endColor[5] + endColor[6], quotient);

				return `#${redColor}${greenColor}${blueColor}`;
			}

			function byteLinear (partOne, partTwo, quotient) {
				let color = Math.floor(('0x' + partOne) * (1 - quotient) + ('0x' + partTwo) * quotient);

				return color.toString(16).padStart(2, '0');
			}

			let pureTimingValue = parseInt(timing);

			// '#17d4a7', '#ffb800', '#e64e3d' - colors are used for timings scale on the map
			if (pureTimingValue <= PROBE_MIN_TIMING) {
				return '#17d4a7';
			}

			if (pureTimingValue >= PROBE_MAX_TIMING) {
				return '#e64e3d';
			}

			return getColorFromGradient(pureTimingValue / PROBE_MAX_TIMING, '#17d4a7', '#ffb800', '#e64e3d');
		},
		createQualityString (isOffline, statsTotal, statsDrop) {
			if (isOffline) { return 'Probe offline'; }

			let { actualAmount, qualityPercentage } = this.calcQuality(statsTotal, statsDrop);

			return qualityPercentage !== null ? `${actualAmount}/${statsTotal} - ${qualityPercentage}%` : '';
		},
		calcQuality (statsTotal, statsDrop) {
			if (
				typeof statsTotal === 'undefined'
				|| typeof statsDrop === 'undefined'
				|| statsTotal === 0
			) {
				return {
					qualityPercentage: null,
					actualAmount: null,
				};
			}

			let actualAmount = Math.max(statsTotal - statsDrop, 0);
			let qualityPercentage = Math.round(actualAmount / statsTotal * 100);

			return {
				qualityPercentage,
				actualAmount,
			};
		},
		createGraph (packetsRtt) {
			let isInfiniteModeRes = this.get('isInfiniteModeRes');

			if (isInfiniteModeRes) {
				return this.createRealTimeGraph(packetsRtt);
			}

			return this.createRegularGraph(packetsRtt);
		},
		createTimingsString (lastTiming, maxTiming, minTiming, avgTiming) {
			if (
				typeof lastTiming === 'undefined'
				|| typeof maxTiming === 'undefined'
				|| typeof minTiming === 'undefined'
				|| typeof avgTiming === 'undefined'
			) {
				return '';
			}

			let avgTimingValue = this.getAvgTimingValueToDisplay(avgTiming);
			let timingStr = `${lastTiming} / ${minTiming} / ${avgTimingValue} / ${maxTiming}`;

			// if probe has timing values - show 'ms', otherwise it is time out
			if (
				lastTiming !== PROBE_NO_TIMING_VALUE
				&& minTiming !== PROBE_NO_TIMING_VALUE
				&& maxTiming !== PROBE_NO_TIMING_VALUE
				&& avgTimingValue !== PROBE_NO_TIMING_VALUE
			) {
				timingStr += ' ms';
			}

			return timingStr;
		},
		parseIPFromRawOutput (raw) {
			let ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/;
			let match = raw.match(ipRegex);
			let ipAddr = match ? match[0] : '';

			return ipAddr;
		},
		getFailureProbeRawOutput (probeData) {
			let rawOutput;
			let { status = null } = probeData.result;

			if (status === PROBE_STATUS_OFFLINE || status === PROBE_STATUS_FAILED) {
				rawOutput = probeData.result.rawOutput;
			}

			return rawOutput;
		},
	};
</script>
