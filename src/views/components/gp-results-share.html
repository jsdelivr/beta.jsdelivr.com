<div class="c-gp-results-share">
	<div class="c-gp-results-share_switch">
		<input id="share-switch"
			type="checkbox"
			class="share-type-switch {{#unless shareResultsAsURL}}checked{{/unless}}"
			twoway="false">

		<label for="share-switch" on-click="@this.set('shareResultsAsURL', !shareResultsAsURL)">
			<span>
				<i class="fa fa-link" aria-hidden="true"></i>
				<span>Share URL</span>
			</span>
			<span>
				<i class="fa fa-terminal" aria-hidden="true"></i>
				<span>Replicate in CLI</span>
			</span>
			<div class="slide-select">
				<div class="selected"></div>
			</div>
		</label>
	</div>

	<div class="c-gp-results-share_content">
		<div id="share-res-text">
			{{shareResTextToDisplay}}
		</div>

		<button as-clipboard data-clipboard-text="{{shareResTextToCopy}}">
			<img width="20"
				height="20"
				src="{{@shared.assetsHost}}/img/globalping/copy-icon-black.svg">
		</button>
	</div>
</div>


<script>
	const clipboard = require('../../assets/js/decorators/clipboard');

	component.exports = {
		decorators: {
			clipboard,
		},
		data () {
			return {
				shareResultsAsURL: true,
				shareResultsText: null,
			};
		},
		onrender () {
			if (!Ractive.isServer) {
				// check shareRes state and create URL or CLI cmd respectively
				this.observe('shareResultsAsURL', (shareResultsAsURL) => {
					let { shareResTextToDisplay, shareResTextToCopy } = this.createShareResText(shareResultsAsURL);

					this.set('shareResTextToDisplay', shareResTextToDisplay);
					this.set('shareResTextToCopy', shareResTextToCopy);
				});
			}
		},
		createShareResText (urlFlow = true) {
			let measurementsMetadata = this.get('measurementsMetadata');
			let infiniteMeasurement = this.get('infiniteMeasurement');

			if (urlFlow) {
				// return URL
				let origin = this.get('@global.location.origin');
				let textToDisplay = Object.values(measurementsMetadata).map(v => v.measurementId).join(',');
				let textToCopy = Object.values(measurementsMetadata).map(v => v.measurementId).join('%2C');

				if (infiniteMeasurement) {
					return {
						shareResTextToDisplay: 'Not supported',
						shareResTextToCopy: 'Not supported',
					};
				}

				return {
					shareResTextToDisplay: `${origin}/globalping?measurement=${textToDisplay}`,
					shareResTextToCopy: `${origin}/globalping?measurement=${textToCopy}`,
				};
			}

			// return CLI cmd
			return this.createCliCommand(this.get('testReqParams'), measurementsMetadata);
		},
		createCliCommand (params, measurementsMetadata) {
			let targetsCnt = Object.values(measurementsMetadata).map(v => v.target).length;
			let infiniteMeasurement = this.get('infiniteMeasurement');

			if (targetsCnt >= 2 && !infiniteMeasurement) {
				return {
					shareResTextToDisplay: 'Not supported yet',
					shareResTextToCopy: 'Not supported yet',
				};
			}

			let cmd = Object.keys(params).reduce((cmd, key) => {
				// test type part
				if (key === 'type') {
					cmd.typePart += ` ${params[key]} ${params.target}`;

					if (params.locations && params.locations.length) {
						let locationStr = params.locations.reduce((str, loc, idx) => {
							let locPart = loc.magic.toLowerCase().trim();

							if (idx === 0) {
								return str += locPart;
							}

							return str += `, ${locPart}`;
						}, '');

						cmd.typePart += ` from ${locationStr}`;
					}

					if (params.measurementOptions) {
						let str = Object.keys(params.measurementOptions).reduce((str, key) => {
							switch (key) {
								case 'packets':
									str += ` --packets ${params.measurementOptions.packets}`; break;

								case 'port':
									str += ` --port ${params.measurementOptions.port}`; break;

								case 'protocol':
									str += ` --protocol ${params.measurementOptions.protocol}`; break;

								case 'type':
									str += ` --type ${params.measurementOptions.type}`; break;

								case 'trace':
									if (params.type.toLowerCase() === 'dns' && params.measurementOptions.trace) {
										str += ' --trace';
									}

									break;

								case 'resolver':
									str += ` --resolver ${params.measurementOptions.resolver}`; break;

								case 'request':
									if (params.measurementOptions.request.host) {
										str += ` --host ${params.measurementOptions.request.host}`;
									}

									if (params.measurementOptions.request.path) {
										let path = params.measurementOptions.request.path;

										path = path[0] === '/' ? path : `/${path}`;
										str += ` --path '${path}'`;
									}

									if (params.measurementOptions.request.query) {
										str += ` --query '${params.measurementOptions.request.query}'`;
									}

									if (params.measurementOptions.request.method) {
										str += ` --method ${params.measurementOptions.request.method}`;
									}

									break;
							}

							return str;
						}, '');

						cmd.typePart += str;
					}
				}

				// global flags part
				if (key === 'limit') {
					cmd.globalPart += ` --limit ${params[key]}`;
				}

				return cmd;
			}, {
				base: 'globalping',
				typePart: '',
				globalPart: '',
			});

			// add infinite flag for the Infinite flow
			if (infiniteMeasurement) {
				cmd.globalPart += ' --infinite';
			}

			return {
				shareResTextToDisplay: cmd.base + cmd.typePart + cmd.globalPart,
				shareResTextToCopy: cmd.base + cmd.typePart + cmd.globalPart,
			};
		},
	};
</script>
