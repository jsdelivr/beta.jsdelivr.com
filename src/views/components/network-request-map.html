<div class="c-network-request-map">
	<div class="map-header">
		<h3>Requests served by country</h3>

		<div class="map-header_switch">
			<button class="button {{ type === 'hits' && 'selected' }}" on-click="@this.set('type', 'hits')">Requests</button>
			<button class="button {{ type === 'bandwidth' && 'selected' }}" on-click="@this.set('type', 'bandwidth')">Bandwidth</button>
		</div>
	</div>

	<div class="map-wrapper">
		<div class="switchers-block">
			{{#each switchList:index}}
				<div class="switchers-block_item {{#if switchList[index].disabled}}disabled{{/if}}">
					<label class="switchers-block_item_switch">
						<input
							class="{{name}}"
							type="checkbox"
							on-click="@this.set('switchList['+@index+'].active', !active)"
							disabled="{{switchList[index].disabled}}"
							checked>
						<span class="slider round"></span>
						</label>
						<span class="switchers-block_item_name">{{name}}</span>
				</div>
			{{/each}}
		</div>

		<div class="map-block">
			<div class="map-block_map-wrapper">
				<svg id="hits-map" class="map-block_map-wrapper_map" xmlns="http://www.w3.org/2000/svg"></svg>

				<div class="map-block_map-wrapper_overlay"></div>

				<div class="map-block_map-wrapper_tooltip">
					<div class="map-block_map-wrapper_tooltip_head">
						<span class="map-block_map-wrapper_tooltip_head_name">{{tooltipData.countryName}}</span>
						<img on-click="@this.hideTooltip()"
							width="20"
							height="20"
							src="{{@shared.assetsHost}}/img/statistics/close.svg">
					</div>

					<div class="map-block_map-wrapper_tooltip_body">
						{{#each tooltipData.providersData}}
							<div class="map-block_map-wrapper_tooltip_body_row">
								<div class="map-block_map-wrapper_tooltip_body_row_box" style="background: {{this.providerBoxColor}}"></div>

								<div class="map-block_map-wrapper_tooltip_body_row_content">
									<div class="map-block_map-wrapper_tooltip_body_row_content_main-data">
										<span>{{ this.provider.name }}</span>
										<span>{{ this.statsInfo }}</span>
									</div>

									<div class="map-block_map-wrapper_tooltip_body_row_content_file-size">
										<span>Average file size</span>
										<span>{{ this.ratio }}</span>
									</div>
								</div>
							</div>
						{{/each}}
					</div>
				</div>
			</div>

			<div class="map-block_legend">
				{{#if legendAxisTicks.length}}
					<div class="map-block_legend_bar"></div>
				{{/if}}

				<div class="map-block_legend_axis">
					{{#each legendAxisTicks}}
						<div class="map-block_legend_axis_tick">{{this}}</div>
					{{/each}}
				</div>
			</div>

			<div class="map-block_ctrls">
				<div class="map-block_ctrls_plus" on-click="@this.handleMapZoom('in')">
					<img src="{{@shared.assetsHost}}/img/statistics/plus.svg">
				</div>

				<div class="map-block_ctrls_minus" on-click="@this.handleMapZoom('out')">
					<img src="{{@shared.assetsHost}}/img/statistics/minus.svg">
				</div>
			</div>
		</div>
	</div>
</div>

<script>
	const http = require('../../public/js/utils/http.js');
	const _ = require('../../public/js/_.js');
	const geoData = require('../../public/json/geodata.json');
	const providersJson = require('../../public/json/net-providers.json');
	const debounce = require('../../public/js/utils/debounce');
	const throttle = require('../../public/js/utils/throttle');
	const LEGEND_AXIS_TICKS_AMOUNT = 7;

	component.exports = {
		data () {
			return {
				type: 'hits',
				switchList: [],
				hitsData: {},
				bandwidthData: {},
				legendAxisTicks: [],
				tooltipData: {},
				currentCountryId: null,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				// fetch data
				this.observe('period __ready', function () {
					if (this.get('__ready')) {
						let period = this.get('period');

						http.fetchNetworkProviderStatsByCountry(period).then(({ hits, bandwidth }) => {
							this.set('hitsData', hits);
							this.set('bandwidthData', bandwidth);

							let providers = Object.values(hits.countries)[0].providers;

							let oldSwitchList = this.get('switchList');
							let newSwitchList = Object.keys(providers).map((key) => {
								let oldOne = oldSwitchList.filter(one => one.name === providersJson[key].name);

								return oldOne.length ? oldOne[0] : { name: providersJson[key].name, active: true, shortName: key };
							});

							this.set('switchList', newSwitchList);
						});
					}
				});

				// handle switchList logic
				this.observe('switchList', (switchList) => {
					let disabledSwitches = switchList.filter(s => s.active === false).length;
					let switchListLength = switchList.length;
					let updatedSwitchList = [];

					if (disabledSwitches === switchListLength - 1) {
						updatedSwitchList = switchList.map((switchItem) => {
							if (switchItem.active) {
								switchItem.disabled = true;
							} else {
								switchItem.disabled = false;
							}

							return switchItem;
						});
					} else {
						updatedSwitchList = switchList.map((switchItem) => {
							switchItem.disabled = false;

							return switchItem;
						});
					}

					this.set('switchList', updatedSwitchList);
				});

				// prepare data for the Map
				this.observe('hitsData bandwidthData type switchList', () => {
					let preparedMapData = {
						dataByCountries: {},
						minMapValue: 0,
						maxMapValue: 0,
						switchList: [],
					};
					let hitsData = this.get('hitsData');
					let bandwidthData = this.get('bandwidthData');
					let switchList = this.get('switchList');
					let type = this.get('type');

					if (!hitsData.countries || !bandwidthData.countries || switchList.length === 0) { return; }

					// prepare countries total, data by countries etc.
					Object.keys(hitsData.countries).forEach((countryAsKey) => {
						let countryHitsStat = hitsData.countries[countryAsKey];
						let countryBandwidthStat = bandwidthData.countries[countryAsKey];
						let ratioList = {};
						let hitsByCountryTotal = 0;
						let bandwidthByCountryTotal = 0;

						Object.keys(countryHitsStat.providers).forEach((providerCode) => {
							let provider = providersJson[providerCode];
							let switchOne = switchList.find(one => one.name === provider.name);

							if (!switchOne.active) { return; }

							ratioList[provider.name] = this.calcRatio(countryHitsStat.providers[providerCode].total, countryBandwidthStat.providers[providerCode].total);
							hitsByCountryTotal += countryHitsStat.providers[providerCode].total;
						});

						Object.keys(countryBandwidthStat.providers).forEach((providerCode) => {
							let provider = providersJson[providerCode];
							let switchOne = switchList.find(one => one.name === provider.name);

							if (!switchOne.active) { return; }

							bandwidthByCountryTotal += countryBandwidthStat.providers[providerCode].total;
						});

						preparedMapData.dataByCountries[countryAsKey] = countryHitsStat;
						preparedMapData.dataByCountries[countryAsKey].total = type === 'hits' ? hitsByCountryTotal : bandwidthByCountryTotal;
						preparedMapData.dataByCountries[countryAsKey].ratio = ratioList;
					});

					// calculate min max values present on the Map
					preparedMapData.minMapValue = _.getValueByMagnitude(
						Math.min(...Object.keys(preparedMapData.dataByCountries).map(k => preparedMapData.dataByCountries[k].total)),
						'floor'
					);

					preparedMapData.maxMapValue = _.getValueByMagnitude(
						Math.max(...Object.keys(preparedMapData.dataByCountries).map(k => preparedMapData.dataByCountries[k].total)),
						'ceil',
						1
					);

					// prepare additional data
					preparedMapData.switchList = switchList;
					preparedMapData.type = type;

					// prepare data for the Legend axis of the Map
					preparedMapData.legendAxisValues = [];

					for (let i = LEGEND_AXIS_TICKS_AMOUNT; i >= 0; i--) {
						let tickValue = preparedMapData.minMapValue + i * (preparedMapData.maxMapValue - preparedMapData.minMapValue) / LEGEND_AXIS_TICKS_AMOUNT;

						preparedMapData.legendAxisValues.push(tickValue);
					}

					// set prepared data
					this.set('preparedMapData', preparedMapData);
				});
			}
		},
		onrender () {
			// draw the Map and the Legend
			this.observe('preparedMapData screenWidth', () => {
				let legendColorRange = [ '#a2ecf6', '#65d69e', '#90eb9d', '#ffff8c', '#f9d057', '#f29e2e', '#e76818', '#d7191c' ];
				let screenWidth = this.get('screenWidth') ? this.get('screenWidth') : innerWidth;
				let svg = d3.select('#hits-map');

				if (!svg || !this.get('__ready') || !screenWidth) { return; }

				let { minMapValue, maxMapValue, dataByCountries, legendAxisValues, type } = this.get('preparedMapData');

				let legendAxisTicks = legendAxisValues.reduce((result, rawValue) => {
					if (screenWidth < 768) {
						result.push(_.formatToShortNumber(rawValue, ' '));
					} else {
						if (type === 'bandwidth') {
							result.push(_.formatNumber(_.convertBytesToUnits(rawValue, 'GB')) + ' G');
						} else {
							result.push(_.formatNumber(Math.round(rawValue)));
						}
					}

					return result;
				}, []);

				this.set('legendAxisTicks', legendAxisTicks);

				svg.selectAll('*').remove();

				let mapSvgWidth = parseInt(svg.style('width').replace('px', ''));
				let mapSvgHeight = parseInt(svg.style('height').replace('px', ''));
				let domainValues = d3.range(legendColorRange.length - 1).map((index) => {
					return minMapValue + index * Math.ceil((maxMapValue - minMapValue) / legendColorRange.length);
				});

				domainValues = [ ...domainValues, maxMapValue ];

				let colorScale = d3.scaleLinear()
					.domain(domainValues)
					.range(legendColorRange)
					.clamp(true)
					.unknown('#ccc');

				// Map and projection
				let projection = d3.geoMercator()
					.scale(mapSvgWidth / 2.5 / Math.PI)
					.center([ 0, 20 ])
					.translate(screenWidth < 768 ? [ mapSvgWidth / 2, mapSvgHeight / 2 ] : [ mapSvgWidth / 2 - 100, mapSvgHeight / 2 + 50 ]);

				// Draw the map
				let mapContainer = svg.append('g')
					.selectAll('path')
					.data(geoData.features)
					.join('path')
					// draw each country
					.attr('d', d3.geoPath().projection(projection))
					// set the color of each country
					.attr('fill', (d) => {
						let countryCode = d.id;

						if (!dataByCountries[countryCode]) {
							// console.log('geo country');
							// console.log(d);
						}

						return colorScale(dataByCountries[countryCode] ? dataByCountries[countryCode].total : null);
					})
					.attr('stroke', 'white')
					.attr('stroke-width', '1px')
					.on('click', (event, d) => {
						if (screenWidth < 768 && this.get('currentCountryId') !== d.id) {
							this.showTooltip(event, d);
							this.set('currentCountryId', d.id);
						}
					})
					.on('mouseover mousemove', (event, d) => {
						if (screenWidth >= 768 && this.get('currentCountryId') !== d.id) {
							this.showTooltip(event, d);
							this.set('currentCountryId', d.id);
						}
					});


				if (screenWidth > 768) {
					mapContainer.on('mouseout', () => {
						this.hideTooltip();
					});
				} else {
					let zoom = d3.zoom()
						.scaleExtent([ 1, 8 ])
						.on('zoom', (event) => {
							svg.selectAll('g')
								.attr('transform', event.transform);
						});

					svg.call(zoom);
				}
			}, { init: false });

			// detect window resize
			window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
		},
		calcRatio (hits, bandwidth) {
			return hits ? _.formatToShortNumber(bandwidth / hits) : 0;
		},
		hideTooltip () {
			let tooltipEl = document.querySelector('.map-block_map-wrapper_tooltip');
			let mapOverlayEl = document.querySelector('.map-block_map-wrapper_overlay');

			tooltipEl.style.opacity = 0;
			tooltipEl.style.zIndex = -1;
			mapOverlayEl.style.opacity = 0;
			mapOverlayEl.style.zIndex = -1;
			this.set('tooltipData', {});
			this.set('currentCountryId', null);
		},
		handleMapZoom (zoomDirection = 'in', scale = 1.4, duration = 750) {
			let mapSvg = d3.select('#hits-map');
			let zoom = d3.zoom()
				.scaleExtent([ 1, 8 ])
				.on('zoom', (event) => {
					mapSvg.selectAll('g')
						.attr('transform', event.transform);
				});

			if (zoomDirection === 'out') {
				scale = 0.6;
			}

			zoom.scaleBy(mapSvg.transition().duration(duration), scale);
		},
		showTooltip (event, data) {
			let { dataByCountries, switchList } = this.get('preparedMapData');
			let { layerX, layerY, type: eventType } = event;
			let { properties: { name: countryName }, id: countryId } = data;
			let tooltipEl = document.querySelector('.map-block_map-wrapper_tooltip');
			let tooltipData = {
				countryName,
				providersData: [],
			};

			tooltipEl.style.opacity = 1;
			tooltipEl.style.zIndex = 2;
			tooltipEl.style.top = `${layerY + 10}px`;
			tooltipEl.style.left = `${layerX + 10}px`;

			if (eventType === 'click') {
				let mapOverlayEl = document.querySelector('.map-block_map-wrapper_overlay');

				mapOverlayEl.style.opacity = 0.6;
				mapOverlayEl.style.zIndex = 1;
			}

			switchList.forEach((provider) => {
				if (!provider.active) { return; }

				let statsInfo = dataByCountries[countryId] ? _.formatNumberWithSpace(dataByCountries[countryId].total) : 0;
				let ratio = dataByCountries[countryId] ? dataByCountries[countryId].ratio[provider.name] : 0;
				let providerBoxColor = providersJson[provider.shortName].color;

				tooltipData.providersData.push({
					statsInfo,
					provider,
					ratio,
					providerBoxColor,
				});
			});

			this.set('tooltipData', tooltipData);
		},
	};
</script>
