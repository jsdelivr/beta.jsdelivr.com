<div class="c-network-request-map">
	<div class="map-header">
		<h3>Requests served by country</h3>

		<div class="map-header_switch">
			<button class="button {{ type === 'hits' && 'selected' }}" on-click="@this.set('type', 'hits')">Requests</button>
			<button class="button {{ type === 'bandwidth' && 'selected' }}" on-click="@this.set('type', 'bandwidth')">Bandwidth</button>
		</div>
	</div>

	<div class="map-wrapper">
		<div class="switchers-block">
			{{#each switchList:index}}
				<div class="switchers-block_item {{#if switchList[index].disabled}}disabled{{/if}}">
					<label class="switchers-block_item_switch">
						<input
							class="{{name}}"
							type="checkbox"
							on-click="@this.set('switchList['+@index+'].active', !active)"
							disabled="{{switchList[index].disabled}}"
							checked>
						<span class="slider round"></span>
						</label>
						<span class="switchers-block_item_name">{{name}}</span>
				</div>
			{{/each}}
		</div>

		<div class="hits-map-block">
			<svg id="hits-map" xmlns="http://www.w3.org/2000/svg"></svg>
			<svg id="map-legend"></svg>
			<div id="tooltip"></div>
			<div class="map-overlay"></div>
		</div>
	</div>
</div>

<script>
	const http = require('../../public/js/utils/http.js');
	const _ = require('../../public/js/_.js');
	const geoData = require('../../public/json/geodata.json');
	const providersJson = require('../../public/json/net-providers.json');
	const debounce = require('../../public/js/utils/debounce');
	const throttle = require('../../public/js/utils/throttle');

	component.exports = {
		data () {
			return {
				type: 'hits',
				switchList: [],
				hitsData: {},
				bandwidthData: {},
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				// fetch data
				this.observe('period __ready', function () {
					if (this.get('__ready')) {
						let period = this.get('period');

						http.fetchNetworkProviderStatsByCountry(period).then(({ hits, bandwidth }) => {
							this.set('hitsData', hits);
							this.set('bandwidthData', bandwidth);

							let providers = Object.values(hits.countries)[0].providers;

							let oldSwitchList = this.get('switchList');
							let newSwitchList = Object.keys(providers).map((key) => {
								let oldOne = oldSwitchList.filter(one => one.name === providersJson[key].name);

								return oldOne.length ? oldOne[0] : { name: providersJson[key].name, active: true, shortName: key };
							});

							this.set('switchList', newSwitchList);
						});
					}
				});

				// handle switchList logic
				this.observe('switchList', (switchList) => {
					let disabledSwitches = switchList.filter(s => s.active === false).length;
					let switchListLength = switchList.length;
					let updatedSwitchList = [];

					if (disabledSwitches === switchListLength - 1) {
						updatedSwitchList = switchList.map((switchItem) => {
							if (switchItem.active) {
								switchItem.disabled = true;
							} else {
								switchItem.disabled = false;
							}

							return switchItem;
						});
					} else {
						updatedSwitchList = switchList.map((switchItem) => {
							switchItem.disabled = false;

							return switchItem;
						});
					}

					this.set('switchList', updatedSwitchList);
				});

				// prepare data for the Map
				this.observe('hitsData bandwidthData type switchList', () => {
					let preparedMapData = {
						dataByCountries: {},
						min: 0,
						max: 0,
						switchList: [],
					};
					let hitsData = this.get('hitsData');
					let bandwidthData = this.get('bandwidthData');
					let switchList = this.get('switchList');
					let type = this.get('type');

					if (!hitsData.countries || !bandwidthData.countries || switchList.length === 0) { return; }

					Object.keys(hitsData.countries).forEach((countryAsKey) => {
						let countryHitsStat = hitsData.countries[countryAsKey];
						let countryBandwidthStat = bandwidthData.countries[countryAsKey];
						let ratioList = {};
						let hitsByCountryTotal = 0;
						let bandwidthByCountryTotal = 0;

						Object.keys(countryHitsStat.providers).forEach((providerCode) => {
							let provider = providersJson[providerCode];
							let switchOne = switchList.find(one => one.name === provider.name);

							if (!switchOne.active) { return; }

							ratioList[provider.name] = this.calcRatio(countryHitsStat.providers[providerCode].total, countryBandwidthStat.providers[providerCode].total);
							hitsByCountryTotal += countryHitsStat.providers[providerCode].total;
						});

						Object.keys(countryBandwidthStat.providers).forEach((providerCode) => {
							let provider = providersJson[providerCode];
							let switchOne = switchList.find(one => one.name === provider.name);

							if (!switchOne.active) { return; }

							bandwidthByCountryTotal += countryBandwidthStat.providers[providerCode].total;
						});

						preparedMapData.dataByCountries[countryAsKey] = countryHitsStat;
						preparedMapData.dataByCountries[countryAsKey].total = type === 'hits' ? hitsByCountryTotal : bandwidthByCountryTotal;
						preparedMapData.dataByCountries[countryAsKey].ratio = ratioList;
					});

					preparedMapData.min = _.getValueByMagnitude(
						Math.min(...Object.keys(preparedMapData.dataByCountries).map(k => preparedMapData.dataByCountries[k].total)),
						'floor'
					);

					preparedMapData.max = _.getValueByMagnitude(
						Math.max(...Object.keys(preparedMapData.dataByCountries).map(k => preparedMapData.dataByCountries[k].total)),
						'ceil',
						1
					);

					preparedMapData.switchList = switchList;

					this.set('preparedMapData', preparedMapData);
				});
			}
		},
		onrender () {
			// draw the Map
			this.observe('preparedMapData screenWidth', () => {
				let svg = d3.select('#hits-map');
				let legendSvg = d3.select('#map-legend');
				let { min, max, dataByCountries, switchList } = this.get('preparedMapData');
				let screenWidth = this.get('screenWidth');

				if (!svg || !this.get('__ready')) { return; }

				svg.selectAll('*').remove();
				legendSvg.selectAll('*').remove();

				let width = parseInt(svg.style('width').replace('px', ''));
				let height = parseInt(svg.style('height').replace('px', ''));

				let legendColorRange = [ '#A2ECF6', '#65D69E', '#90eb9d', '#ffff8c', '#f9d057', '#f29e2e', '#e76818', '#d7191c' ];
				let domainValues = d3.range(legendColorRange.length - 1)
					.map((index) => {
						return min + index * Math.ceil((max - min) / legendColorRange.length);
					});
				domainValues = [ ...domainValues, max ];

				let colorScale = d3.scaleLinear()
					.domain(domainValues)
					.range(legendColorRange)
					.clamp(true)
					.unknown('#ccc');

				let defs = '';

				if (screenWidth < 768) {
					defs = legendSvg.append('defs');
				} else {
					defs = svg.append('defs');
				}

				let linearGradient = defs.append('linearGradient')
					.attr('id', 'linear-gradient');
				linearGradient.selectAll('stop')
					.data(colorScale.range())
					.enter().append('stop')
					.attr('offset', (d, i) => { return i / (colorScale.range().length - 1); })
					.attr('stop-color', (d) => { return d; });

				let legendPosition = {
					x: width - 130,
					y: (height + 420) / 2,
				};

				if (screenWidth < 768) {
					let legendSvgWidth = parseInt(legendSvg.style('width').replace('px', ''));
					legendSvg.append('rect')
						.attr('transform', `rotate(-180, ${legendSvgWidth / 2}, 5)`)
						.attr('x', 0)
						.attr('y', 0)
						.attr('width', legendSvgWidth)
						.attr('height', 10)
						.attr('rx', 6)
						.attr('ry', 6)
						.style('fill', 'url(#linear-gradient)');

					legendSvg.append('g')
						.attr('class', 'legend-text')
						.selectAll('text')
						.data(colorScale.range())
						.enter()
						.append('text')
						.attr('x', (d, index) => {
							return (legendSvgWidth - 20) - index * (legendSvgWidth - 20) / (legendColorRange.length - 1);
						})
						.attr('y', 30)
						.style('fill', '#5C667A')
						.style('font-size', '12px')
						.style('line-height', '16px')
						.text((d, index) => {
							let value = min + index * (max - min) / (legendColorRange.length - 1);
							return _.formatToShortNumber(value);
						});
				} else {
					svg.append('rect')
						.attr('transform', `rotate(-90, ${legendPosition.x}, ${legendPosition.y})`)
						.attr('x', legendPosition.x)
						.attr('y', legendPosition.y)
						.attr('width', 420)
						.attr('height', 16)
						.attr('rx', 6)
						.attr('ry', 6)
						.style('fill', 'url(#linear-gradient)');

					svg.append('g')
						.attr('class', 'legend-text')
						.selectAll('text')
						.data(colorScale.range())
						.enter()
						.append('text')
						.attr('x', legendPosition.x + 30)
						.attr('y', (d, index) => {
							return legendPosition.y - index * 420 / (legendColorRange.length - 1);
						})
						.style('fill', 'black')
						.text((d, index) => {
							let value = min + index * (max - min) / (legendColorRange.length - 1);
							return value > 1e9 ? _.convertBytesToUnits(value, 'GB') + 'G' : value;
						});
				}

				// Map and projection
				// let path = d3.geoPath();
				let projection = d3.geoMercator()
					.scale(width / 2.5 / Math.PI)
					.center([ 0, 20 ])
					.translate(screenWidth < 768 ? [ width / 2, height / 2 ] : [ width / 2 - 100, height / 2 + 50 ]);


				// Draw the map
				let mapContainer = svg.append('g')
					.selectAll('path')
					.data(geoData.features)
					.join('path')
				// draw each country
					.attr('d', d3.geoPath().projection(projection))
				// set the color of each country
					.attr('fill', (d) => {
						let countryCode = d.id;

						if (!dataByCountries[countryCode]) {
							// console.log('geo country');
							// console.log(d);
						}

						return colorScale(dataByCountries[countryCode] ? dataByCountries[countryCode].total : null);
					})
					.attr('stroke', 'white')
					.attr('stroke-width', '1px')
					.on('mouseover mousemove', (event, d) => {
						d3.select('#tooltip')
							.selectAll('*')
							.remove();

						/** *map overlay for mobile***/
						d3.select('.map-overlay')
							.style('width', `${width}px`)
							.style('height', `${height}px`)
							.style('display', 'block');

						/** *tooltip for map***/
						d3.select('#tooltip')
							.style('left', `${event.layerX + 10}px`)
							.style('top', `${event.layerY + 10}px`)
							.style('display', 'block')
							.append('div')
							.attr('class', 'title')
							.text(d.properties.name)
							.append('img')
							.attr('src', '/img/statistics/close.svg')
							.on('click', () => {
								this.hideTooltip();
							});

						switchList.forEach((one) => {
							if (!one.active) { return; }

							let statsInfo = dataByCountries[d.id] ? _.formatNumberWithSpace(dataByCountries[d.id].total) : 0;
							let ratio = dataByCountries[d.id] ? dataByCountries[d.id].ratio[one.name] : 0;

							let statsDiv = d3.select('#tooltip')
								.append('div')
								.attr('class', `stats ${one.name}`);

							let textContainer = statsDiv.append('div')
								.attr('class', 'text-container');
							let textDiv = textContainer.append('div')
								.attr('class', 'text');
							textDiv.append('span')
								.text(one.name);

							textDiv.append('span')
								.text(statsInfo);

							textDiv = textContainer.append('div')
								.attr('class', 'text');

							textDiv.append('span')
								.text('Average file size');

							textDiv.append('span')
								.text(ratio);
						});
					});


				if (screenWidth > 768) {
					mapContainer.on('mouseout', () => {
						this.hideTooltip();
					});
				} else {
					let zoom = d3.zoom()
						.scaleExtent([ 1, 8 ])
						.on('zoom', (event) => {
							svg.selectAll('g')
								.attr('transform', event.transform);
						});
					svg.append('rect')
						.attr('x', width - 45)
						.attr('y', height - 80)
						.attr('width', 32)
						.attr('height', 32)
						.attr('fill', '#fff')
						.attr('rx', 6)
						.attr('ry', 6);

					svg.append('image')
						.attr('href', '/img/statistics/plus.svg')
						.attr('x', width - 37)
						.attr('y', height - 74)
						.on('click', () => {
							zoom.scaleBy(svg.transition().duration(750), 1.4);
						});

					svg.append('rect')
						.attr('x', width - 45)
						.attr('y', height - 55)
						.attr('width', 32)
						.attr('height', 32)
						.attr('fill', '#fff')
						.attr('rx', 6)
						.attr('ry', 6);

					svg.append('image')
						.attr('href', '/img/statistics/minus.svg')
						.attr('x', width - 37)
						.attr('y', height - 46)
						.on('click', () => {
							zoom.scaleBy(svg.transition().duration(750), 0.6);
						});

					svg.call(zoom);
				}
			}, { init: false });

			// detect window resize
			window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
		},
		calcRatio (hits, bandwidth) {
			return hits ? _.formatToShortNumber(bandwidth / hits) : 0;
		},
		hideTooltip () {
			d3.select('.map-overlay')
				.style('display', 'none');

			d3.select('#tooltip')
				.style('display', 'none');
		},
};
</script>
