<div class="c-network-request-map">
	<div class="map-header">
		<h3>Requests served by country</h3>

		<div class="map-header_switch">
			<button class="button {{ type === 'hits' && 'selected' }}" on-click="@this.set('type', 'hits')">Requests</button>
			<button class="button {{ type === 'bandwidth' && 'selected' }}" on-click="@this.set('type', 'bandwidth')">Bandwidth</button>
		</div>
	</div>

	<div class="map-wrapper">
		<div class="switchers-block">
			{{#each switchList:index}}
				<div class="switchers-block_item {{#if switchList[index].disabled}}disabled{{/if}}">
					<label class="switchers-block_item_switch">
						<input
							class="{{name}}"
							type="checkbox"
							on-click="@this.set('switchList['+@index+'].active', !active)"
							disabled="{{switchList[index].disabled}}"
							checked>
						<span class="slider round"></span>
						</label>
						<span class="switchers-block_item_name">{{name}}</span>
				</div>
			{{/each}}
		</div>

		<div class="hits-map-block">
			<svg id="hits-map" xmlns="http://www.w3.org/2000/svg"></svg>
			<div class="hits-map-block_legend">
				<div class="hits-map-block_legend_bar"></div>
				<div class="hits-map-block_legend_axis">
					{{#each legendAxisTicks}}
						<div class="hits-map-block_legend_axis_tick">{{this}}</div>
					{{/each}}
				</div>
			</div>

			<div id="tooltip"></div>

			<div class="map-overlay"></div>

			<div class="hits-map-block_ctrls">
				<div class="hits-map-block_ctrls_plus" on-click="@this.handleMapZoom('in')">
					<img src="{{@shared.assetsHost}}/img/statistics/plus.svg">
				</div>

				<div class="hits-map-block_ctrls_minus" on-click="@this.handleMapZoom('out')">
					<img src="{{@shared.assetsHost}}/img/statistics/minus.svg">
				</div>
			</div>
		</div>
	</div>
</div>

<script>
	const http = require('../../public/js/utils/http.js');
	const _ = require('../../public/js/_.js');
	const geoData = require('../../public/json/geodata.json');
	const providersJson = require('../../public/json/net-providers.json');
	const debounce = require('../../public/js/utils/debounce');
	const throttle = require('../../public/js/utils/throttle');

	component.exports = {
		data () {
			return {
				type: 'hits',
				switchList: [],
				hitsData: {},
				bandwidthData: {},
				legendAxisTicks: [],
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				// fetch data
				this.observe('period __ready', function () {
					if (this.get('__ready')) {
						let period = this.get('period');

						http.fetchNetworkProviderStatsByCountry(period).then(({ hits, bandwidth }) => {
							this.set('hitsData', hits);
							this.set('bandwidthData', bandwidth);

							let providers = Object.values(hits.countries)[0].providers;

							let oldSwitchList = this.get('switchList');
							let newSwitchList = Object.keys(providers).map((key) => {
								let oldOne = oldSwitchList.filter(one => one.name === providersJson[key].name);

								return oldOne.length ? oldOne[0] : { name: providersJson[key].name, active: true, shortName: key };
							});

							this.set('switchList', newSwitchList);
						});
					}
				});

				// handle switchList logic
				this.observe('switchList', (switchList) => {
					let disabledSwitches = switchList.filter(s => s.active === false).length;
					let switchListLength = switchList.length;
					let updatedSwitchList = [];

					if (disabledSwitches === switchListLength - 1) {
						updatedSwitchList = switchList.map((switchItem) => {
							if (switchItem.active) {
								switchItem.disabled = true;
							} else {
								switchItem.disabled = false;
							}

							return switchItem;
						});
					} else {
						updatedSwitchList = switchList.map((switchItem) => {
							switchItem.disabled = false;

							return switchItem;
						});
					}

					this.set('switchList', updatedSwitchList);
				});

				// prepare data for the Map
				this.observe('hitsData bandwidthData type switchList', () => {
					let preparedMapData = {
						dataByCountries: {},
						minMapValue: 0,
						maxMapValue: 0,
						switchList: [],
					};
					let hitsData = this.get('hitsData');
					let bandwidthData = this.get('bandwidthData');
					let switchList = this.get('switchList');
					let type = this.get('type');

					if (!hitsData.countries || !bandwidthData.countries || switchList.length === 0) { return; }

					// prepare countries total, data by countries etc.
					Object.keys(hitsData.countries).forEach((countryAsKey) => {
						let countryHitsStat = hitsData.countries[countryAsKey];
						let countryBandwidthStat = bandwidthData.countries[countryAsKey];
						let ratioList = {};
						let hitsByCountryTotal = 0;
						let bandwidthByCountryTotal = 0;

						Object.keys(countryHitsStat.providers).forEach((providerCode) => {
							let provider = providersJson[providerCode];
							let switchOne = switchList.find(one => one.name === provider.name);

							if (!switchOne.active) { return; }

							ratioList[provider.name] = this.calcRatio(countryHitsStat.providers[providerCode].total, countryBandwidthStat.providers[providerCode].total);
							hitsByCountryTotal += countryHitsStat.providers[providerCode].total;
						});

						Object.keys(countryBandwidthStat.providers).forEach((providerCode) => {
							let provider = providersJson[providerCode];
							let switchOne = switchList.find(one => one.name === provider.name);

							if (!switchOne.active) { return; }

							bandwidthByCountryTotal += countryBandwidthStat.providers[providerCode].total;
						});

						preparedMapData.dataByCountries[countryAsKey] = countryHitsStat;
						preparedMapData.dataByCountries[countryAsKey].total = type === 'hits' ? hitsByCountryTotal : bandwidthByCountryTotal;
						preparedMapData.dataByCountries[countryAsKey].ratio = ratioList;
					});

					// calculate min max values present on the Map
					preparedMapData.minMapValue = _.getValueByMagnitude(
						Math.min(...Object.keys(preparedMapData.dataByCountries).map(k => preparedMapData.dataByCountries[k].total)),
						'floor'
					);

					preparedMapData.maxMapValue = _.getValueByMagnitude(
						Math.max(...Object.keys(preparedMapData.dataByCountries).map(k => preparedMapData.dataByCountries[k].total)),
						'ceil',
						1
					);

					// prepare additional data
					preparedMapData.switchList = switchList;
					preparedMapData.type = type;

					// prepare data for the Legend axis of the Map
					preparedMapData.legendAxisValues = [];

					for (let i = 7; i >= 0; i--) {
						preparedMapData.legendAxisValues.push(preparedMapData.minMapValue + i * (preparedMapData.maxMapValue - preparedMapData.minMapValue) / 7);
					}

					// set prepared data
					this.set('preparedMapData', preparedMapData);
				});
			}
		},
		onrender () {
			// draw the Map and the Legend
			this.observe('preparedMapData screenWidth', () => {
				let legendColorRange = [ '#a2ecf6', '#65d69e', '#90eb9d', '#ffff8c', '#f9d057', '#f29e2e', '#e76818', '#d7191c' ];
				let screenWidth = this.get('screenWidth') ? this.get('screenWidth') : innerWidth;
				let svg = d3.select('#hits-map');

				if (!svg || !this.get('__ready') || !screenWidth) { return; }

				let { minMapValue, maxMapValue, dataByCountries, switchList, legendAxisValues, type } = this.get('preparedMapData');

				let legendAxisTicks = legendAxisValues.reduce((result, rawValue) => {
					if (screenWidth < 768) {
						result.push(_.formatToShortNumber(rawValue));
					} else {
						if (type === 'bandwidth') {
							result.push(_.convertBytesToUnits(rawValue, 'GB') + 'G');
						} else {
							result.push(Math.round(rawValue));
						}
					}

					return result;
				}, []);

				this.set('legendAxisTicks', legendAxisTicks);

				svg.selectAll('*').remove();

				let width = parseInt(svg.style('width').replace('px', ''));
				let height = parseInt(svg.style('height').replace('px', ''));
				let domainValues = d3.range(legendColorRange.length - 1).map((index) => {
					return minMapValue + index * Math.ceil((maxMapValue - minMapValue) / legendColorRange.length);
				});

				domainValues = [ ...domainValues, maxMapValue ];

				let colorScale = d3.scaleLinear()
					.domain(domainValues)
					.range(legendColorRange)
					.clamp(true)
					.unknown('#ccc');

				// Map and projection
				let projection = d3.geoMercator()
					.scale(width / 2.5 / Math.PI)
					.center([ 0, 20 ])
					.translate(screenWidth < 768 ? [ width / 2, height / 2 ] : [ width / 2 - 100, height / 2 + 50 ]);


				// Draw the map
				let mapContainer = svg.append('g')
					.selectAll('path')
					.data(geoData.features)
					.join('path')
					// draw each country
					.attr('d', d3.geoPath().projection(projection))
					// set the color of each country
					.attr('fill', (d) => {
						let countryCode = d.id;

						if (!dataByCountries[countryCode]) {
							// console.log('geo country');
							// console.log(d);
						}

						return colorScale(dataByCountries[countryCode] ? dataByCountries[countryCode].total : null);
					})
					.attr('stroke', 'white')
					.attr('stroke-width', '1px')
					.on('mouseover mousemove', (event, d) => {
						d3.select('#tooltip')
							.selectAll('*')
							.remove();

						/** *map overlay for mobile***/
						d3.select('.map-overlay')
							.style('width', `${width}px`)
							.style('height', `${height}px`)
							.style('display', 'block');

						/** *tooltip for map***/
						d3.select('#tooltip')
							.style('left', `${event.layerX + 10}px`)
							.style('top', `${event.layerY + 10}px`)
							.style('display', 'block')
							.append('div')
							.attr('class', 'title')
							.text(d.properties.name)
							.append('img')
							.attr('src', '/img/statistics/close.svg')
							.on('click', () => {
								this.hideTooltip();
							});

						switchList.forEach((one) => {
							if (!one.active) { return; }

							let statsInfo = dataByCountries[d.id] ? _.formatNumberWithSpace(dataByCountries[d.id].total) : 0;
							let ratio = dataByCountries[d.id] ? dataByCountries[d.id].ratio[one.name] : 0;

							let statsDiv = d3.select('#tooltip')
								.append('div')
								.attr('class', `stats ${one.name}`);

							let textContainer = statsDiv.append('div')
								.attr('class', 'text-container');
							let textDiv = textContainer.append('div')
								.attr('class', 'text');
							textDiv.append('span')
								.text(one.name);

							textDiv.append('span')
								.text(statsInfo);

							textDiv = textContainer.append('div')
								.attr('class', 'text');

							textDiv.append('span')
								.text('Average file size');

							textDiv.append('span')
								.text(ratio);
						});
					});


				if (screenWidth > 768) {
					mapContainer.on('mouseout', () => {
						this.hideTooltip();
					});
				} else {
					let zoom = d3.zoom()
						.scaleExtent([ 1, 8 ])
						.on('zoom', (event) => {
							svg.selectAll('g')
								.attr('transform', event.transform);
						});

					svg.call(zoom);
				}
			}, { init: false });

			// detect window resize
			window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
		},
		calcRatio (hits, bandwidth) {
			return hits ? _.formatToShortNumber(bandwidth / hits) : 0;
		},
		hideTooltip () {
			d3.select('.map-overlay')
				.style('display', 'none');

			d3.select('#tooltip')
				.style('display', 'none');
		},
		handleMapZoom (zoomDirection = 'in', scale = 1.4, duration = 750) {
			let mapSvg = d3.select('#hits-map');
			let zoom = d3.zoom()
				.scaleExtent([ 1, 8 ])
				.on('zoom', (event) => {
					mapSvg.selectAll('g')
						.attr('transform', event.transform);
				});

			if (zoomDirection === 'out') {
				scale = 0.6;
			}

			zoom.scaleBy(mapSvg.transition().duration(duration), scale);
		},
	};
</script>
