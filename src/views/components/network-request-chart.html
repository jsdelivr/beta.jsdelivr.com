<div class="c-network-request-chart">
	<div class="chart-header">
		<h3>Requests served over time</h3>

		<div class="chart-header_switch">
			<button class="button {{ showChartBandwidth ? '' : 'selected' }}" on-click="@this.set('showChartBandwidth', false)">Requests</button>
			<button class="button {{ showChartBandwidth ? 'selected' : '' }}" on-click="@this.set('showChartBandwidth', true)">Bandwidth</button>
		</div>
	</div>

	<div class="hits-chart-block">
		<div class="hits-chart-block_switcher">
			{{#each switchList}}
				<div class="switch-item">
					<label class="switch">
						<input class="{{ name }}" type="checkbox" on-click="@this.set('switchList['+@index+'].active', !active)" checked>
						<span class="slider round"></span>
						</label>
						<span class="name">{{name}}</span>
				</div>
			{{/each}}
		</div>

		<div class="hits-chart-block_chart-wrapper">
			<canvas id="hits-chart"></canvas>
		</div>
	</div>
</div>

<script>
	const _ = require('../../public/js/_');
	const http = require('../../public/js/utils/http');
	const createLineChart = require('../../public/js/utils/create-line-chart');
	const providersJson = require('../../public/json/net-providers.json');
	const debounce = require('../../public/js/utils/debounce');
	const throttle = require('../../public/js/utils/throttle');

	component.exports = {
		data () {
			return {
				showChartBandwidth: false,
				switchList: [],
				rawHitsChartData: '',
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('period country __ready', function () {
					if (this.get('__ready')) {
						let period = this.get('period');
						let country = this.get('country') || '';

						if (country === 'WW') { country = ''; }

						http.fetchNetworkProviderStats(period, country).then((response) => {
							let { providers: respProviders } = response.hits;

							let oldSwitchList = this.get('switchList');
							let newSwitchList = Object.keys(respProviders).map((key) => {
								let oldOne = oldSwitchList.filter(one => one.name === providersJson[key].name);

								return oldOne.length ? oldOne[0] : { name: providersJson[key].name, active: true };
							});

							this.set('switchList', newSwitchList);
							this.set('rawHitsChartData', response);
						});
					}
				});

				this.observe('rawHitsChartData showChartBandwidth screenWidth', () => {
					let rawHitsChartData = this.get('rawHitsChartData');
					let chartPeriod = this.get('period');
					let showChartBandwidth = this.get('showChartBandwidth');
					let usageChartGroupBy = 'day';
					let screenWidth = this.get('screenWidth') ? this.get('screenWidth') : innerWidth;

					// collect X-Axis dates, group data by period, get
					let {
						labels,
						maxRangeValue,
						datasets,
						labelsStartEndPeriods,
						valueUnits,
					} = _.getPreparedProvidersDataForLineChart(rawHitsChartData, usageChartGroupBy, chartPeriod, showChartBandwidth);

					this.set('preparedHitsChartData', {
						datasets,
						labels,
						labelsStartEndPeriods,
						maxRangeValue,
						showChartBandwidth,
						useYAxisBorderPlugin: screenWidth >= 768,
						yAxisPadding: screenWidth >= 768 ? 30 : 18,
						valueUnits,
						usageChartGroupBy,
					});
				}, { init: false });
			}
		},
		onrender () {
			let hitsChart;

			// create hits chart
			this.observe('preparedHitsChartData', (preparedHitsChartData) => {
				let {
					datasets,
					labels,
					maxRangeValue,
					useYAxisBorderPlugin,
					showChartBandwidth,
					yAxisPadding,
					labelsStartEndPeriods,
					valueUnits,
					usageChartGroupBy,
				} = preparedHitsChartData;
				let hitsChartCanvasEl = this.find('#hits-chart');

				if (!preparedHitsChartData || !hitsChartCanvasEl) { return; }

				if (hitsChart) {
					hitsChart.destroy();
					hitsChart = null;
				}

				let chartData = {
					labels,
					datasets,
					labelsStartEndPeriods,
					valueUnits,
					usageChartGroupBy,
				};
				let chartSettings = {
					useYAxisBorderPlugin,
					useExternalTooltip: true,
					useImprovedTooltip: true,
					plugins: {
						useExternalTooltip: true,
					},
				};
				let maxRangeMagnitude = Math.floor(Math.log10(maxRangeValue));
				let chartConfig = {
					options: {
						scales: {
							x: {
								display: true,
								ticks: {
									autoSkip: false,
									color: '#5C667A',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
										lineHeight: 2,
									},
									callback (value) {
										let labelValue = this.getLabelForValue(value);

										if (labelValue.length) {
											return labelValue;
										}
									},
								},
								grid: {
									display: false,
									drawBorder: false,
								},
							},
							y: {
								display: true,
								min: 0,
								suggestedMax: Math.ceil(maxRangeValue / Math.pow(10, maxRangeMagnitude)) * Math.pow(10, maxRangeMagnitude),
								ticks: {
									padding: yAxisPadding,
									count: 9,
									color: '#5C667A',
									crossAlign: 'near',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
									},
									callback (value) {
										let valueByMagnitude = _.getValueByMagnitude(Math.round(value), 'round', 1, false);

										if (_.isMobileScreen()) {
											return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatToShortNumber(valueByMagnitude);
										}

										return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatNumber(valueByMagnitude);
									},
								},
								grid: {
									drawBorder: false,
									color: '#CFD6DD',
									tickLength: 0,
								},
							},
						},
					},
				};

				hitsChart = createLineChart(hitsChartCanvasEl, chartData, chartSettings, chartConfig);
			}, { init: false });

			// detect window resize
			window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
		},
	};
</script>
