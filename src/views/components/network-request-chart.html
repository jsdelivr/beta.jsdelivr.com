<div class="c-network-request-chart">
	<style>
		{{#each providersJson}}
			.hits-chart-block_switchers_item_switch input.{{name}}:checked + .slider {
				background-color: {{color}};
			}

			.hits-chart-block_switchers_item_switch input.{{name}}:focus + .slider {
				box-shadow: 0 0 1px {{color}};
			}
		{{/each}}
	</style>

	<div class="chart-header">
		<h3>Requests served over time</h3>

		<div class="chart-header_switch">
			<button class="button {{ showChartBandwidth ? '' : 'selected' }}" on-click="@this.set('showChartBandwidth', false)">Requests</button>
			<button class="button {{ showChartBandwidth ? 'selected' : '' }}" on-click="@this.set('showChartBandwidth', true)">Bandwidth</button>
		</div>
	</div>

	<div class="hits-chart-block">
		<div class="hits-chart-block_switchers">
			<div class="hits-chart-block_switchers_item">
				<label class="hits-chart-block_switchers_item_switch">
					<input
						type="checkbox"
						on-click="@this.toggle('showProviderBreakdown')"
						checked>
					<span class="slider round provider-breakdown {{#unless showProviderBreakdown}}provider-breakdown_turned-off{{/unless}}"></span>
					</label>
					<span class="hits-chart-block_switchers_item_name">Show provider breakdown</span>
			</div>

			{{#each switchList:index}}
				<div class="hits-chart-block_switchers_item {{#if switchList[index].disabled}}disabled{{/if}}">
					<label class="hits-chart-block_switchers_item_switch">
						<input
							class="{{name}}"
							type="checkbox"
							on-click="@this.set('switchList['+@index+'].active', !active)"
							disabled="{{switchList[index].disabled}}"
							checked>
						<span class="slider round"></span>
						</label>
						<span class="hits-chart-block_switchers_item_name">{{name}}</span>
				</div>
			{{/each}}
		</div>

		<div class="hits-chart-block_chart-wrapper">
			<canvas id="hits-chart"></canvas>
		</div>
	</div>
</div>

<script>
	const _ = require('../../public/js/_');
	const http = require('../../public/js/utils/http');
	const createLineChart = require('../../public/js/utils/create-line-chart');
	const providersJson = require('../../public/json/net-providers.json');
	const debounce = require('../../public/js/utils/debounce');
	const throttle = require('../../public/js/utils/throttle');

	component.exports = {
		data () {
			return {
				showChartBandwidth: false,
				switchList: [],
				rawHitsChartData: '',
				providersJson,
				showProviderBreakdown: true,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('period country __ready', function () {
					if (this.get('__ready')) {
						let period = this.get('period');
						let country = this.get('country') || '';

						if (country === 'WW') { country = ''; }

						http.fetchNetworkProviderStats(period, country).then((response) => {
							let { providers: respProviders } = response.hits;

							let oldSwitchList = this.get('switchList');
							let newSwitchList = Object.keys(respProviders).map((key) => {
								let oldOne = oldSwitchList.filter(one => one.name === providersJson[key].name);

								return oldOne.length ? oldOne[0] : { name: providersJson[key].name, active: true, shortName: key };
							});

							this.set('switchList', newSwitchList);
							this.set('rawHitsChartData', response);
						});
					}
				});

				this.observe('switchList', (switchList) => {
					let disabledSwitches = switchList.filter(s => s.active === false).length;
					let switchListLength = switchList.length;
					let updatedSwitchList = [];

					if (disabledSwitches === switchListLength - 1) {
						updatedSwitchList = switchList.map((switchItem) => {
							if (switchItem.active) {
								switchItem.disabled = true;
							} else {
								switchItem.disabled = false;
							}

							return switchItem;
						});
					} else {
						updatedSwitchList = switchList.map((switchItem) => {
							switchItem.disabled = false;

							return switchItem;
						});
					}

					this.set('switchList', updatedSwitchList);
				});

				this.observe('rawHitsChartData showChartBandwidth screenWidth switchList', () => {
					let rawHitsChartData = this.get('rawHitsChartData');
					let switchList = this.get('switchList');

					if (!rawHitsChartData || switchList.length === 0) { return; }

					let chartPeriod = this.get('period');
					let showChartBandwidth = this.get('showChartBandwidth');
					let screenWidth = this.get('screenWidth') ? this.get('screenWidth') : innerWidth;
					let usageChartGroupBy = 'day';
					let notActiveSwitches = switchList.filter(s => s.active === false).map(s => s.shortName);
					let hitsProviders = { ...rawHitsChartData.hits.providers };
					let bandwidthProviders = { ...rawHitsChartData.bandwidth.providers };

					notActiveSwitches.forEach((s) => {
						delete hitsProviders[s];
						delete bandwidthProviders[s];
					});

					let filteredHitsChartData = {
						...rawHitsChartData,
						bandwidth: {
							...rawHitsChartData.bandwidth,
							providers: bandwidthProviders,
						},
						hits: {
							...rawHitsChartData.hits,
							providers: hitsProviders,
						},
					};

					// collect X-Axis dates, group data by period, get
					let {
						labels,
						maxRangeValue,
						datasets,
						labelsStartEndPeriods,
						valueUnits,
					} = _.getPreparedProvidersDataForLineChart(filteredHitsChartData, usageChartGroupBy, chartPeriod, showChartBandwidth);

					this.set('preparedHitsChartData', {
						datasets,
						labels,
						labelsStartEndPeriods,
						maxRangeValue,
						showChartBandwidth,
						yAxisPadding: screenWidth >= 768 ? 24 : 12,
						valueUnits,
						usageChartGroupBy,
					});
				}, { init: false });
			}
		},
		onrender () {
			let hitsChart;

			// create hits chart
			this.observe('preparedHitsChartData', (preparedHitsChartData) => {
				let {
					datasets,
					labels,
					maxRangeValue,
					showChartBandwidth,
					yAxisPadding,
					labelsStartEndPeriods,
					valueUnits,
					usageChartGroupBy,
				} = preparedHitsChartData;
				let hitsChartCanvasEl = this.find('#hits-chart');

				if (!preparedHitsChartData || !hitsChartCanvasEl) { return; }

				if (hitsChart) {
					hitsChart.destroy();
					hitsChart = null;
				}

				let chartData = {
					labels,
					datasets,
					labelsStartEndPeriods,
					valueUnits,
					usageChartGroupBy,
				};
				let chartSettings = {
					useExternalTooltip: true,
					useImprovedTooltip: true,
					plugins: {
						useExternalTooltip: true,
					},
				};
				let maxRangeMagnitude = Math.floor(Math.log10(maxRangeValue));
				let chartConfig = {
					options: {
						scales: {
							x: {
								display: true,
								ticks: {
									autoSkip: false,
									color: '#5C667A',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
										lineHeight: 2,
									},
									callback (value) {
										let labelValue = this.getLabelForValue(value);

										if (labelValue.length) {
											return labelValue;
										}
									},
								},
								grid: {
									display: false,
									drawBorder: false,
								},
							},
							y: {
								display: true,
								min: 0,
								suggestedMax: Math.ceil(maxRangeValue / Math.pow(10, maxRangeMagnitude)) * Math.pow(10, maxRangeMagnitude),
								ticks: {
									padding: yAxisPadding,
									count: 9,
									color: '#5C667A',
									crossAlign: 'near',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
									},
									callback (value) {
										let valueByMagnitude = _.getValueByMagnitude(Math.round(value), 'round', 1, false);

										if (_.isMobileScreen()) {
											return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatToShortNumber(valueByMagnitude);
										}

										return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatNumber(valueByMagnitude);
									},
								},
								grid: {
									drawBorder: false,
									color: '#CFD6DD',
									tickLength: 0,
								},
							},
						},
					},
				};

				hitsChart = createLineChart(hitsChartCanvasEl, chartData, chartSettings, chartConfig);
			}, { init: false });

			// detect window resize
			window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
		},
	};
</script>
