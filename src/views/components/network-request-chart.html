<div class="c-network-request-chart">
	<div class="chart-header">
		<h3>Requests served over time</h3>
		<div>
			<button class="button {{ type === 'hits' && 'selected' }}" on-click="@this.set('type', 'hits')">Requests</button>
			<button class="button {{ type === 'bandwidth' && 'selected' }}" on-click="@this.set('type', 'bandwidth')">Bandwidth</button>
		</div>
	</div>
	<div class="hits-chart-wrapper">
		<div class="switch-block">
			{{#each switchList}}
				<div class="switch-item">
					<label class="switch">
						<input class="{{ name }}" type="checkbox" on-click="@this.set('switchList['+@index+'].active', !active)" checked>
						<span class="slider round"></span>
						</label>
						<span class="name">{{name}}</span>
				</div>
			{{/each}}
		</div>
		<div class="hits-chart-block">
			<canvas id="hits-chart"></canvas>
		</div>
	</div>
</div>

<script>
	const _ = require('../../public/js/_');
	const http = require('../../public/js/utils/http');
	const createLineChart = require('../../public/js/utils/create-line-chart');
	const providers = require('../../public/json/net-providers.json');

	component.exports = {
		data () {
			return {
				type: 'hits',
				switchList: [],
				hitsData: '',
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('period country __ready', function () {
					if (this.get('__ready')) {
						let period = this.get('period');
						let country = this.get('country') || '';

						if (country === 'WW') { country = ''; }

						http.fetchNetworkProviderStats(period, country)
							.then((res) => {
								res = res.providers;

								let oldSwitchList = this.get('switchList');
								let newSwitchList = Object.keys(res)
									.map((key) => {
										let oldOne = oldSwitchList.filter(one => one.name === providers[key].name);

										return oldOne.length ? oldOne[0] : { name: providers[key].name, active: true };
									});
								this.set('switchList', newSwitchList);
								this.set('hitsData', res);
							});
					}
				});
			}
		},
		onrender () {
			let hitsChart;

			// create hits chart
			this.observe('hitsData switchList type', () => {
				let switchList = this.get('switchList');
				let hitsData = this.get('hitsData');
				let type = this.get('type');
				let hitsChartCanvasEl = this.find('#hits-chart');

				if (switchList.length === 0 || !hitsData || !hitsChartCanvasEl) { return; }

				let array = [];
				Object.keys(hitsData).forEach((key) => {
					let provider = switchList.filter(one => one.name === providers[key].name);

					if (!provider[0]?.active) { return; }

					let ratioList = {};
					Object.keys(hitsData[key][type].dates).forEach((date) => {
						let hits = hitsData[key].hits.dates[date];
						let bandwidth = hitsData[key].bandwidth.dates[date];

						ratioList[date] = hits ? _.formatToShortNumber(bandwidth / hits) : 0;
					});

					array.push({
						label: key,
						data: Object.values(hitsData[key][type].dates),
						dates: Object.keys(hitsData[key][type].dates),
						ratio: ratioList,
						borderColor: providers[key].color,
						backgroundColor: providers[key].color,
					});
				});

				if (hitsChart) {
					hitsChart.destroy();
					hitsChart = null;
				}

				if (!array.length) { return; }

				let yAxisTicksAmount = 8;
				let minRangeValue = _.getValueByMagnitude(
					Math.min(...array.map(one => Math.min(...one.data.filter(v => v !== 0)))),
					'floor'
				);
				let maxRangeValue = _.getValueByMagnitude(
					Math.max(...array.map(one => Math.max(...one.data))),
					'ceil',
					1
				);

				let chartPeriod = this.get('period');
				console.log(chartPeriod);
				let chartData = {
					labels: _.getChartXAxisData(array[0].dates, chartPeriod),
					datasets: array,
				};
				let chartSettings = {
					useExternalTooltip: true,
					plugins: {
						verticalYAxisBorder: false,
					},
				};
				let chartConfig = {
					options: {
						scales: {
							x: {
								display: true,
								ticks: {
									color: '#5C667A',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
										lineHeight: 2,
									},
									// whole callback needed to prepare dates for displaying on the x-axis
									// since we need only the day and not full date (which we must to pass here for the tooltip title)
									callback (tickIdx) {
										let labelValue = this.getLabelForValue(tickIdx);
										let day = Array.isArray(labelValue) ? labelValue[0].split('-').slice(-1)[0] : labelValue.split('-').slice(-1)[0];

										if (chartPeriod === 'year') {
											if (labelValue[2]) {
												if (_.isMobileScreen()) { return [ `${labelValue[2]} ${labelValue[1]}` ]; }

												return [ labelValue[1], labelValue[2] ];
											}

											if (labelValue[1] && !_.isMobileScreen()) { return [ labelValue[1] ]; }

											return;
										}

										if (Array.isArray(labelValue) && labelValue[1]) {
											return [ day, labelValue[1] ];
										}

										if (chartPeriod === 'month' && _.isMobileScreen()) { return; }

										return [ day ];
									},
								},
								grid: {
									display: false,
									drawBorder: false,
								},
							},
							y: {
								display: true,
								min: minRangeValue,
								max: maxRangeValue,
								ticks: {
									count: yAxisTicksAmount,
									color: '#5C667A',
									crossAlign: 'far',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
									},
									callback (tickIdx) {
										let labelValue = this.getLabelForValue(tickIdx);
										return _.formatToShortNumber(_.getValueByMagnitude(Math.round(labelValue.replace(/,/g, '')), 'round', 1, false));
									},
								},
								grid: {
									drawBorder: false,
									color: '#CFD6DD',
									tickLength: 0,
								},
							},
						},
					},
				};

				hitsChart = createLineChart(hitsChartCanvasEl, chartData, chartSettings, chartConfig);
			});
		},
	};
</script>
