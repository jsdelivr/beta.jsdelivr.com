<link rel="ractive" href="./collection-box.html" name="c-collection-box">
<link rel="ractive" href="./package-file-browser.html" name="c-package-file-browser">
<link rel="ractive" href="./package-header.html" name="c-package-header">
<link rel="ractive" href="./package-install-block.html" name="c-package-install-block">
<link rel="ractive" href="./top-stats-table.html" name="c-top-stats-table">
<link rel="ractive" href="./package-sidemenu.html" name="c-package-sidemenu">
<link rel="ractive" href="./markdown.html" name="c-markdown">
<link rel="ractive" href="./package-request-bandwidth-stats.html" name="c-package-request-bandwidth-stats">

<div class="c-package">
	<div class="page-content">
		<div class="page-content_top-content-wrapper">
			<div class="main-content">
				<c-package-header
					package="{{package}}"
					type="{{type}}"
					name="{{name}}"
					version="{{versionP}}"
					packageVersionsNotFound="{{packageVersionsNotFound}}">
				</c-package-header>

				<c-package-install-block
					package="{{package}}"
					type="{{type}}"
					name="{{name}}"
					version="{{versionP}}">
				</c-package-install-block>

				<div class="package-nav">
					{{#if package.readme}}
						<a id="navRouteReadme" on-click="@this.set('navRoute', 'readme')" class="package-nav_route {{navRoute === 'readme' ? 'package-nav_route_active' : ''}}">
							<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/book.svg"><span>{{navMenuTitles.readmeTabTitle}}</span>
						</a>
					{{/if}}
					<a id="navRouteConfig" on-click="@this.set('navRoute', 'config')" class="package-nav_route {{navRoute === 'config' ? 'package-nav_route_active' : ''}}">
						<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/settings.svg"><span>{{navMenuTitles.configTabTitle}}</span>
					</a>
					<a id="navRouteStats" on-click="@this.set('navRoute', 'stats')" class="package-nav_route {{navRoute === 'stats' ? 'package-nav_route_active' : ''}}">
						<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/statistics.svg"><span>{{navMenuTitles.statsTabTitle}}</span>
					</a>
					<a id="navRouteCdn" target="_blank" rel="noopener noreferrer" href="https://cdn.jsdelivr.net/npm/{{name}}/" class="package-nav_route">
						<span>{{navMenuTitles.browseCdnTitle}}</span><img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/external-link.svg">
					</a>
				</div>

				{{#if navRoute === 'readme' && package.readme}}
					<div class="package-readme">
						<c-markdown text="{{package.readme}}"></c-markdown>
					</div>
				{{/if}}
			</div>

			<div class="side-content">
				<c-package-sidemenu
					navRoute="{{navRoute}}"
					name="{{name}}"
					type="{{type}}"
					package="{{package}}">
				</c-package-sidemenu>
			</div>
		</div>

		<div style="display: {{#if navRoute === 'config'}}flex{{else}}none{{/if}};" class="package-config full-width-content">
			<c-package-file-browser
				type="{{type}}"
				name="{{name}}"
				github="{{package.githubRepo}}"
				version="{{versionP}}"
				versions="{{packageVersionsList}}"
				path="{{path}}"
				collection="{{collection}}"
				files="{{~/files}}">
			</c-package-file-browser>

			<c-collection-box collection="{{collection}}"></c-collection-box>
		</div>

		<div style="display: {{#if navRoute === 'stats'}}block{{else}}none{{/if}};" class="package-statistics full-width-content">
			<div class="header">
				<div class="header-title">Statistics</div>
				<div class="header-ctrls">
					<div class="data-range-ctrl">
						<span>Data range:</span>

						<div class="btn-group">
							<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
								<span>{{~/statsPeriods[statsPeriodTemp]}}</span>
								<i class="fa fa-angle-down" aria-hidden="true"></i>
							</button>

							<ul class="dropdown-menu">
								{{#each ~/statsPeriods}}
									<li><a on-click="@this.changeStatsPeriod(@key)">{{this}}</a></li>
								{{/each}}
							</ul>
						</div>
					</div>
				</div>
			</div>

			<c-package-request-bandwidth-stats
				name="{{name}}"
				type="{{type}}"
				period="{{statsPeriods[statsPeriodTemp]}}"
				bandwidthUnit="GB">
			</c-package-request-bandwidth-stats>

			{{#if noPackageStatsData && noVersionsData}}
				<div class="no-data-wrapper">
					<img width="180" height="152" src="{{@shared.assetsHost}}/img/no-data-chart-main.svg">
					<span>No statistics yet</span>
					<span>This is probably not a very popular package :(</span>
				</div>
			{{else}}
				<div class="chart-stats-per-period">
					<div class="package-usage">
						<div class="small-headline">Stats for last {{~/statsPeriods[statsPeriod]}}</div>

						<div class="chart-type-ctrl">
							<span>Show numbers of</span>

							<input id="chart-switch"
								type="checkbox"
								class="chart-type-switch {{#if showChartBandwidth}}checked{{/if}}"
								twoway="false">

							<label for="chart-switch" on-click="@this.set('showChartBandwidth', !showChartBandwidth)">
								<span>Request</span>
								<span>GB</span>
							</label>
						</div>

						<div class="group-by-ctrl">
							<span>
								Group by:
							</span>

							<div class="btn-group">
								<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
									<span>{{~/usageChartGroupByValues[usageChartGroupBy].value}}</span>
									<i class="fa fa-angle-down" aria-hidden="true"></i>
								</button>

								<ul class="dropdown-menu">
									{{#each ~/usageChartGroupByValues}}
										<li>
											{{#if this.isDisabled}}
												<a class="disabled">{{this.value}}</a>
											{{else}}
												<a on-click="@this.set('usageChartGroupBy', @key)">{{this.value}}</a>
											{{/if}}
										</li>
									{{/each}}
								</ul>
							</div>
						</div>
					</div>

					<div class="stats-chart-wrapper">
						<canvas id="stats-chart"></canvas>
					</div>
				</div>

				<div class="horizontal-divider"></div>

				<div class="chart-tops">
					{{#if ~/topFiveVersionsTemp}}
						<c-top-stats-table title="Top 5 versions" data="{{~/topFiveVersionsTemp}}" type="{{~/type}}" name="{{~/name}}" version="{{~/fileStatsVersion}}">
							{{#partial column1}}
								<a on-click="@this.set('version', version)">{{version}}</a>
							{{/partial}}
						</c-top-stats-table>

						<c-top-stats-table data="{{~/fileStats ? ~/fileStats.slice(0, 5): []}}"
							type="{{~/type}}"
							name="{{~/name}}"
							version="{{~/fileStatsVersion}}"
							versions="{{~/packageVersionsList}}">
							{{#partial header}}
								Top 5 files in version
								<c-version-dropdown versions="{{versions}}" version="{{version}}"></c-version-dropdown>
							{{/partial}}

							{{#partial column1}}
								<a title="{{file}}" target="_blank" rel="noopener noreferrer" href="https://cdn.jsdelivr.net/{{~/type}}/{{~/name}}@{{~/version}}{{file}}">{{file}}</a>
							{{/partial}}
						</c-top-stats-table>
					{{/if}}
				</div>

				<div class="horizontal-divider"></div>

				<div class="chart-hits-per-period">
					<div class="package-usage">
						<div class="small-headline">Hits per {{~/statsPeriods[statsPeriod]}} per version</div>
					</div>

					<div class="hits-chart-wrapper">
						<canvas id="hits-chart"></canvas>
					</div>

					<div class="hits-chart-legend">
						{{#each topFiveVersions}}
							<div class="legend-item">
								<div></div>
								{{version}}
							</div>
						{{/each}}
					</div>
				</div>
			{{/if}}
		</div>
	</div>
</div>

<script>
	const _ = require('../../public/js/_');
	const http = require('../../public/js/utils/http');
	const debounce = require('../../public/js/utils/debounce');
	const throttle = require('../../public/js/utils/throttle');
	const clipboard = require('../../public/js/decorators/clipboard');
	const tooltip = require('../../public/js/decorators/tooltip');
	const createBarChart = require('../../public/js/utils/create-bar-chart');
	const createLineChart = require('../../public/js/utils/create-line-chart');

	component.exports = {
		computed: {
			hasSourceMaps () {
				let files = this.get('files');
				let hasMin, hasMap;

				if (!files) {
					return true;
				}

				_.flattenFiles(files).forEach((file) => {
					if (/\.min\.(?:js|css)$/.test(file)) {
						hasMin = true;
					} else if (/\.map$/.test(file)) {
						hasMap = true;
					}
				});

				return !hasMin || hasMap;
			},
			issueSourceMaps () {
				return `https://github.com/${this.get('package.githubRepo.user')}/${this.get('package.githubRepo.project')}/issues/new/`
					+ `?title=No source maps for minified files`
					+ `&body=[This package](${this.get('@global.location.href')}) doesn't contain source maps for the minified files. It would be great to add them for easier debugging.`;
			},
		},
		data () {
			return {
				_,
				collection: [],
				statsPeriods: {
					1: 'day',
					7: 'week',
					30: 'month',
					365: 'year',
				},
				statsPeriodTemp: 30,
				statsPeriod: 30,
				packageVersionsList: [],
				navRoute: 'readme',
				showChartBandwidth: false,
				usageChartGroupByValues: {
					day: { value: 'day', isDisabled: false },
					week: { value: 'week', isDisabled: false },
					month: { value: 'month', isDisabled: false },
				},
				usageChartGroupBy: 'day',
				noPackageStatsData: false,
				noVersionsData: false,
				versionsHitsTotal: 0,
			};
		},
		decorators: {
			clipboard,
			tooltip,
		},
		oninit () {
			if (!Ractive.isServer) {
				// //////////////////// REVIEWED CODE
				// http.fetchPackageVersionStats (Get top 5 versions for table, get package versions data)
				// http.fetchPackageDateStats (get package date stats data)
				// http.fetchPackageBandwidthStats (get package date stats data)

				// load Package Versions List (ShowFilesTab, Top-5-files-per-version dropdown-menu)
				http.fetchPackageVersions(this.get('type'), this.get('name')).then((data) => {
					this.set('packageVersionsList', data.versions);

					// This can only happen for GitHub packages.
					if (data.versions.length === 0) {
						return this.set({ packageVersionsNotFound: true });
					}

					// Set version for GitHub packages.
					if (!this.get('package.version')) {
						this.set('package.version', data.versions[0]);
					}

					// Set version for GitHub packages or when an invalid version is selected.
					if (!this.get('versionP') || data.versions.indexOf(this.get('versionP')) === -1) {
						this.set('versionP', data.versions[0]);
					}
				}).catch((error) => {
					this.set({ packageNotFound: true });
					console.error(`Package versions not found.`, error);
				});

				// fetch Package Version File Stats for Top-5-file-per-package-version
				this.observe('statsPeriodTemp fileStatsVersion', () => {
					if (this.get('statsPeriodTemp') && this.get('fileStatsVersion')) {
						let type = this.get('type');
						let name = this.get('name');
						let version = this.get('fileStatsVersion');
						let period = this.get('statsPeriods')[this.get('statsPeriodTemp')];

						http.fetchPackageFileStats(type, name, version, period).then((data) => {
							let fileStats = Object.keys(data.files).map(key => ({
								file: key,
								hits: data.files[key].total,
							})).sort((a, b) => b.hits - a.hits);

							this.animate('fileStats', fileStats);
						});
					}
				});


				// get Package Version Stats for Top-5-package-versions
				this.observe('statsPeriodTemp versionP navRoute', () => {
					if (this.get('statsPeriodTemp') && this.get('versionP')) {
						let type = this.get('type');
						let name = this.get('name');
						let period = this.get('statsPeriods')[this.get('statsPeriodTemp')];

						http.fetchPackageVersionStats(type, name, period).then((response) => {
							let topFiveVersionsTemp = Object.keys(response.versions).map(key => ({
								version: key,
								hits: response.versions[key].total,
								dates: response.versions[key].dates,
							})).sort((a, b) => b.hits - a.hits).slice(0, 5);

							this.animate('topFiveVersionsTemp', topFiveVersionsTemp);
						});
					}
				});

				// change Nav Menu titles depending on the screen size (also on the resize of the page)
				this.observe('screenWidth', (newScreenWidth) => {
					let shortTitles = {
						readmeTabTitle: 'Readme',
						configTabTitle: 'Show Files',
						statsTabTitle: 'Statistics',
						browseCdnTitle: 'CDN',
					};
					let fullTitles = {
						readmeTabTitle: 'Readme',
						configTabTitle: 'Show/Configure Files',
						statsTabTitle: 'Statistics',
						browseCdnTitle: 'Browse CDN Files',
					};
					let actualScreenWidth = newScreenWidth ? newScreenWidth : screen.width;

					if (actualScreenWidth >= 992 && actualScreenWidth < 1200) {
						this.set('navMenuTitles', shortTitles);
					} else {
						this.set('navMenuTitles', fullTitles);
					}
				});


				// //////////////////// NOT REVIEWED CODE

				// get package data (for charts, etc.)
				this.observe('statsPeriod showChartBandwidth versionP navRoute', () => {
					if (this.get('statsPeriod') && this.get('versionP')) {
						let type = this.get('type');
						let name = this.get('name');
						let period = this.get('statsPeriods')[this.get('statsPeriod')];
						let showChartBandwidth = this.get('showChartBandwidth');

						// get package date stats data
						if (showChartBandwidth) {
							http.fetchPackageBandwidthStats(type, name, period).then((response) => {
								if (!response.total) {
									this.set('noPackageStatsData', true);
									return;
								}

								this.set('noPackageStatsData', false);
								this.set('statsDateData', response);
							});
						} else {
							http.fetchPackageDateStats(type, name, period).then((response) => {
								if (!response.total) {
									this.set('noPackageStatsData', true);
									return;
								}

								this.set('noPackageStatsData', false);
								this.set('statsDateData', response);
							});
						}

						// get package versions data
						http.fetchPackageVersionStats(type, name, period).then((response) => {
							if (!response.total) {
								this.set('noVersionsData', true);
								return;
							}

							this.set('noVersionsData', false);
							this.set('hitsData', response);
						});
					}
				});

				// check if Package has readme, if not - show config tab as default
				this.observe('package', () => {
					// package.readme
					let readme = this.get('package').readme;

					if (!readme || readme === 'ERROR: No README data found!') {
						this.set('navRoute', 'config');
					}
				});

				if (!this.get('versionP')) {
					this.set('versionP', this.get('package.version'));
				}

				// control the value of the DateRange and change the value of the GroupBy respectively
				this.observe('statsPeriod', (statsPeriod) => {
					let statsPeriods = this.get('statsPeriods');
					let usageChartGroupByValues = this.get('usageChartGroupByValues');
					let usageChartGroupBy = this.get('usageChartGroupBy');

					switch (statsPeriods[statsPeriod]) {
						case 'day':
							usageChartGroupBy = 'day';
							usageChartGroupByValues.day.isDisabled = false;
							usageChartGroupByValues.week.isDisabled = true;
							usageChartGroupByValues.month.isDisabled = true;
							break;

						case 'week':
							if (usageChartGroupBy === 'month') {
								usageChartGroupBy = 'week';
							}

							usageChartGroupByValues.day.isDisabled = false;
							usageChartGroupByValues.week.isDisabled = false;
							usageChartGroupByValues.month.isDisabled = true;
							break;

						default:
							usageChartGroupByValues.day.isDisabled = false;
							usageChartGroupByValues.week.isDisabled = false;
							usageChartGroupByValues.month.isDisabled = false;
					}

					this.set('usageChartGroupBy', usageChartGroupBy);
					this.set('usageChartGroupByValues', usageChartGroupByValues);
				});
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				let statsChart;
				let hitsChart;

				// create stats chart
				this.observe('statsDateData usageChartGroupBy', () => {
					let statsDateData = this.get('statsDateData');
					let statsChartCanvasEl = this.find('#stats-chart');

					if (!statsDateData || !statsChartCanvasEl) { return; }

					let array = [];

					Object.keys(statsDateData.dates).forEach((date) => {
						array.push([ date, statsDateData.dates[date] ]);
					});

					array.sort((a, b) => new Date(a[0]) - new Date(b[0]));

					if (statsChart) {
						statsChart.destroy();
						statsChart = null;
					}

					let usageChartGroupBy = this.get('usageChartGroupBy');
					let groupBy = { day: 1, week: 7, month: 30, year: 365 };
					let groupedDayCount = groupBy[usageChartGroupBy];

					let countDay = 0;
					let xAxisDates = [];
					array.forEach((value) => {
						countDay++;

						if (countDay % groupedDayCount === 0) {
							countDay = 0;
							xAxisDates.push(value[0]);
						}
					});

					let groupData = [];
					let tempData = 0;
					countDay = 0;
					let showChartBandwidth = this.get('showChartBandwidth');
					let tempGB = 1;

					if (showChartBandwidth) {
						tempGB = 1e9;
					}

					Object.keys(statsDateData.dates).forEach((date) => {
						countDay++;
						tempData += statsDateData.dates[date].total;

						if (countDay >= groupedDayCount) {
							groupData.push(Math.round(tempData / tempGB));
							countDay = 0; tempData = 0;
						}
					});

					let chartPeriod = this.get('statsPeriods')[this.get('statsPeriod')];
					let yAxisTicksAmount = 8;
					let minRangeValue = _.getValueByMagnitude(Math.min(...groupData), 'floor');
					let maxRangeValue = _.getValueByMagnitude(Math.max(...groupData), 'ceil', 1);

					let chartData = {
						labels: _.getChartXAxisData(xAxisDates, chartPeriod, usageChartGroupBy),
						datasets: [{
							data: groupData,
							borderWidth: 0,
							barThickness: xAxisDates.length < 20 ? 10 : xAxisDates.length < 60 ? 5 : 2,
							hoverBackgroundColor: '#F65128',
						}],
					};
					let chartSettings = {
						useYAxisBorderPlugin: true,
						useExternalTooltip: true,
						externalTooltipVerticalOffset: 40,
					};
					let chartConfig = {
						options: {
							scales: {
								x: {
									display: true,
									ticks: {
										color: '#5C667A',
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
											lineHeight: 2,
										},
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);
											let day = Array.isArray(labelValue) ? labelValue[0].split('-').slice(-1)[0] : labelValue.split('-').slice(-1)[0];

											if (chartPeriod === 'year') {
												if (labelValue[2]) {
													return [ labelValue[1], labelValue[2] ];
												}

												return;
											}

											if (Array.isArray(labelValue)) {
												return [ day, labelValue[1] ];
											}

											return [ day ];
										},
									},
									grid: {
										display: false,
										drawBorder: false,
									},
								},
								y: {
									display: true,
									min: minRangeValue,
									max: maxRangeValue,
									ticks: {
										count: yAxisTicksAmount,
										color: '#5C667A',
										crossAlign: 'near',
										padding: 22,
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
										},
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);
											return _.formatNumber(_.getValueByMagnitude(Math.round(labelValue.replace(/,/g, '')), 'round', 2, false)) + (showChartBandwidth ? ' GB' : '');
										},
									},
									grid: {
										display: false,
										drawBorder: false,
									},
								},
							},
						},
					};

					statsChart = createBarChart(statsChartCanvasEl, chartData, chartSettings, chartConfig);
				});

				// create hits chart
				this.observe('hitsData', (hitsData) => {
					let hitsChartCanvasEl = this.find('#hits-chart');

					if (!hitsData || !hitsChartCanvasEl) { return; }

					let array = [];

					Object.keys(hitsData.versions).forEach((key) => {
						array.push({
							version: key,
							hits: hitsData.versions[key].total,
							dates: hitsData.versions[key].dates,
						});
					});

					let topFiveVersions = array.sort((a, b) => b.hits - a.hits).slice(0, 5);

					this.animate('versionsHitsTotal', hitsData.total);
					this.animate('topFiveVersions', topFiveVersions);

					// Maybe we have no stats yet.
					if (array[0]) {
						this.set('fileStatsVersion', array[0].version);
					}

					if (hitsChart) {
						hitsChart.destroy();
						hitsChart = null;
					}

					let yAxisTicksAmount = 8;
					let minRangeValue = _.getValueByMagnitude(
						Math.min(...topFiveVersions.map(version => Math.min(...Object.values(version.dates).filter(v => v !== 0)))),
						'floor'
					);
					let maxRangeValue = _.getValueByMagnitude(
						Math.max(...topFiveVersions.map(version => Math.max(...Object.values(version.dates)))),
						'ceil',
						1
					);
					let datasets = topFiveVersions.reduce((datasets, tfvItem, idx) => {
						let dataset = {
							label: `v${tfvItem.version}`,
							data: Object.values(tfvItem.dates),
						};

						switch (idx) {
							case 0:
								dataset.borderColor = '#5C667A';
								dataset.backgroundColor = '#5C667A';
								break;
							case 1:
								dataset.borderColor = '#BC5090';
								dataset.backgroundColor = '#BC5090';
								break;
							case 2:
								dataset.borderColor = '#FFA600';
								dataset.backgroundColor = '#FFA600';
								break;
							case 3:
								dataset.borderColor = '#FF6361';
								dataset.backgroundColor = '#FF6361';
								break;
							case 4:
								dataset.borderColor = '#69C4F7';
								dataset.backgroundColor = '#69C4F7';
								break;
						}

						datasets.push(dataset);

						return datasets;
					}, []);
					let chartPeriod = this.get('statsPeriods')[this.get('statsPeriod')];
					let chartData = {
						labels: _.getChartXAxisData(Object.keys(topFiveVersions[0].dates), chartPeriod),
						datasets,
					};
					let chartSettings = {
						useExternalTooltip: true,
					};
					let chartConfig = {
						options: {
							scales: {
								x: {
									display: true,
									// offset: true,
									ticks: {
										color: '#5C667A',
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
											lineHeight: 2,
										},
										// whole callback needed to prepare dates for displaying on the x-axis
										// since we need only the day and not full date (which we must to pass here for the tooltip title)
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);
											// check if it is not contains only a date but also a month
											let day = Array.isArray(labelValue) ? labelValue[0].split('-').slice(-1)[0] : labelValue.split('-').slice(-1)[0];

											if (chartPeriod === 'year') {
												if (labelValue[2]) {
													return [ labelValue[1], labelValue[2] ];
												}

												return;
											}

											if (Array.isArray(labelValue)) {
												return [ day, labelValue[1] ];
											}

											return [ day ];
										},
									},
									grid: {
										display: false,
										drawBorder: false,
									},
								},
								y: {
									display: true,
									min: minRangeValue,
									max: maxRangeValue,
									ticks: {
										count: yAxisTicksAmount,
										color: '#5C667A',
										crossAlign: 'near',
										padding: 48,
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
										},
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);
											return _.formatNumber(_.getValueByMagnitude(Math.round(labelValue.replace(/,/g, '')), 'round', 1, false));
										},
									},
									grid: {
										drawBorder: false,
										color: '#CFD6DD',
										tickLength: 0,
									},
									afterFit: (scale) => {
										scale.width = 114;
									},
								},
							},
						},
					};

					// console.log('hits chartData : ', chartData);

					hitsChart = createLineChart(hitsChartCanvasEl, chartData, chartSettings, chartConfig);
				});

				// detect window resize
				window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', screen.width), 200)));
			}
		},
		changeStatsPeriod (strKey) {
			this.set('statsPeriodTemp', strKey);

			if (strKey > 1) {
				this.set('statsPeriod', strKey);
			}
		},
	};
</script>
