<link rel="ractive" href="./collection-box.html" name="c-collection-box">
<link rel="ractive" href="./package-file-browser.html" name="c-package-file-browser">
<link rel="ractive" href="./package-header.html" name="c-package-header">
<link rel="ractive" href="./package-install-block.html" name="c-package-install-block">
<link rel="ractive" href="./top-stats-table.html" name="c-top-stats-table">
<link rel="ractive" href="./package-sidemenu.html" name="c-package-sidemenu">
<link rel="ractive" href="./markdown.html" name="c-markdown">
<link rel="ractive" href="./package-request-bandwidth-stats.html" name="c-package-request-bandwidth-stats">

<div class="c-package">
	<div class="page-content">
		<div class="page-content_top-content-wrapper">
			<div class="main-content">
				<c-package-header
					package="{{package}}"
					type="{{type}}"
					name="{{name}}"
					version="{{versionP}}"
					packageVersionsNotFound="{{packageVersionsNotFound}}">
				</c-package-header>

				<c-package-install-block
					package="{{package}}"
					type="{{type}}"
					name="{{name}}"
					version="{{versionP}}">
				</c-package-install-block>

				<div class="package-nav">
					{{#if package.readme}}
						<a id="navRouteReadme" on-click="@this.set('navRoute', NAV_MENU_TABS.readme)" class="package-nav_route {{navRoute === NAV_MENU_TABS.readme ? 'package-nav_route_active' : ''}}">
							<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/book.svg"><span>{{navMenuTitles.readmeTabTitle}}</span>
						</a>
					{{/if}}
					<a id="navRouteConfig" on-click="@this.set('navRoute', NAV_MENU_TABS.config)" class="package-nav_route {{navRoute === NAV_MENU_TABS.config ? 'package-nav_route_active' : ''}}">
						<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/settings.svg"><span>{{navMenuTitles.configTabTitle}}</span>
					</a>
					<a id="navRouteStats" on-click="@this.set('navRoute', NAV_MENU_TABS.stats)" class="package-nav_route {{navRoute === NAV_MENU_TABS.stats ? 'package-nav_route_active' : ''}}">
						<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/statistics.svg"><span>{{navMenuTitles.statsTabTitle}}</span>
					</a>
					<a id="navRouteCdn" target="_blank" rel="noopener noreferrer" href="https://cdn.jsdelivr.net/npm/{{name}}/" class="package-nav_route">
						<span>{{navMenuTitles.browseCdnTitle}}</span><img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/external-link.svg">
					</a>
				</div>

				{{#if navRoute === NAV_MENU_TABS.readme && package.readme}}
					<div class="package-readme">
						<c-markdown text="{{package.readme}}"></c-markdown>
					</div>
				{{/if}}
			</div>

			<div class="side-content">
				<c-package-sidemenu
					navRoute="{{navRoute}}"
					name="{{name}}"
					type="{{type}}"
					package="{{package}}">
				</c-package-sidemenu>
			</div>
		</div>

		<div style="display: {{#if navRoute === NAV_MENU_TABS.config}}flex{{else}}none{{/if}};" class="package-config full-width-content">
			<c-package-file-browser
				type="{{type}}"
				name="{{name}}"
				github="{{package.githubRepo}}"
				version="{{versionP}}"
				versions="{{packageVersionsList}}"
				path="{{path}}"
				collection="{{collection}}">
			</c-package-file-browser>

			<c-collection-box collection="{{collection}}"></c-collection-box>
		</div>

		<div
			style="visibility: {{#if navRoute === NAV_MENU_TABS.stats}}visible; height: auto;{{else}}hidden; height: 0;{{/if}}"
			class="package-statistics full-width-content">
			<div class="header">
				<div class="header-title">Statistics</div>
				<div class="header-ctrls">
					<div class="data-range-ctrl">
						<span>Data range:</span>

						<div class="btn-group">
							<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
								<span>{{~/statsPeriods[statsPeriod]}}</span>
								<i class="fa fa-angle-down" aria-hidden="true"></i>
							</button>

							<ul class="dropdown-menu">
								{{#each ~/statsPeriods}}
									<li><a on-click="@this.set('statsPeriod', @key)">{{this}}</a></li>
								{{/each}}
							</ul>
						</div>
					</div>
				</div>
			</div>

			{{#if navRoute === NAV_MENU_TABS.stats}}
				<c-package-request-bandwidth-stats
					name="{{name}}"
					type="{{type}}"
					period="{{statsPeriods[statsPeriod]}}"
					bandwidthUnit="GB">
				</c-package-request-bandwidth-stats>
			{{/if}}

			{{#if noPackageStatsData && noVersionsData}}
				<div class="no-data-wrapper">
					<img width="180" height="152" src="{{@shared.assetsHost}}/img/no-data-chart-main.svg">
					<span>No statistics yet</span>
					<span>This is probably not a very popular package :(</span>
				</div>
			{{else}}
				<div class="chart-stats-per-period">
					<div class="package-usage">
						<div class="small-headline">Stats for last {{~/statsPeriods[statsPeriod]}}</div>

						<div class="chart-type-ctrl">
							<span>Show numbers of</span>

							<input id="chart-switch"
								type="checkbox"
								class="chart-type-switch {{#if showChartBandwidth}}checked{{/if}}"
								twoway="false">

							<label for="chart-switch" on-click="@this.set('showChartBandwidth', !showChartBandwidth)">
								<span>Requests</span>
								<span>Bandwidth</span>
								<div class="slide-select">
									<div class="selected"></div>
								</div>
							</label>
						</div>

						<div class="group-by-ctrl">
							<span>
								Group by:
							</span>

							<div class="btn-group">
								<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
									<span>{{~/usageChartGroupByValues[usageChartGroupBy].value}}</span>
									<i class="fa fa-angle-down" aria-hidden="true"></i>
								</button>

								<ul class="dropdown-menu">
									{{#each ~/usageChartGroupByValues}}
										<li>
											{{#if this.isAvailable}}
												<a on-click="@this.set('usageChartGroupBy', @key)">{{this.value}}</a>
											{{/if}}
										</li>
									{{/each}}
								</ul>
							</div>
						</div>
					</div>

					<div class="stats-chart-wrapper">
						<canvas id="stats-chart"></canvas>
					</div>
				</div>

				<div class="horizontal-divider"></div>

				<div class="chart-tops">
					{{#if ~/topFiveVersions}}
						<c-top-stats-table
							title="Top 5 versions"
							data="{{~/topFiveVersions}}"
							type="{{~/type}}"
							name="{{~/name}}"
							version="{{~/fileStatsVersion}}"
							formatValue="{{showChartBandwidth ? _.formatBytesToGB : _.formatNumber}}"
						>
							{{#partial column1}}
								<a on-click="@this.set('version', version)">{{version}}</a>
							{{/partial}}
						</c-top-stats-table>

						<c-top-stats-table
							data="{{~/filesStats}}"
							type="{{~/type}}"
							name="{{~/name}}"
							version="{{~/fileStatsVersion}}"
							versions="{{~/packageVersionsList}}"
							formatValue="{{showChartBandwidth ? _.formatBytesToGB : _.formatNumber}}"
						>
							{{#partial header}}
								Top 5 files in version
								<c-version-dropdown versions="{{versions}}" version="{{version}}"></c-version-dropdown>
							{{/partial}}

							{{#partial column1}}
								<a title="{{file}}" target="_blank" rel="noopener noreferrer" href="https://cdn.jsdelivr.net/{{~/type}}/{{~/name}}@{{~/version}}{{file}}">
									{{file}}
								</a>
							{{/partial}}
						</c-top-stats-table>
					{{/if}}
				</div>

				<div class="horizontal-divider"></div>

				<div class="chart-hits-per-period">
					<div class="package-usage">
						<div class="small-headline">Hits per {{~/statsPeriods[statsPeriod]}} per version</div>
					</div>

					<div class="hits-chart-wrapper">
						<canvas id="hits-chart"></canvas>
					</div>

					<div class="hits-chart-legend">
						{{#each hitsChartLegendVersions}}
							<div class="legend-item">
								<div></div>
								{{version}}
							</div>
						{{/each}}
					</div>
				</div>
			{{/if}}
		</div>
	</div>
</div>

<script>
	const _ = require('../../public/js/_');
	const http = require('../../public/js/utils/http');
	const debounce = require('../../public/js/utils/debounce');
	const throttle = require('../../public/js/utils/throttle');
	const clipboard = require('../../public/js/decorators/clipboard');
	const tooltip = require('../../public/js/decorators/tooltip');
	const createBarChart = require('../../public/js/utils/create-bar-chart');
	const createLineChart = require('../../public/js/utils/create-line-chart');
	const NAV_MENU_SHORT_TITLES = {
		readmeTabTitle: 'Readme',
		configTabTitle: 'Show Files',
		statsTabTitle: 'Statistics',
		browseCdnTitle: 'CDN',
	};
	const NAV_MENU_FULL_TITLES = {
		readmeTabTitle: 'Readme',
		configTabTitle: 'Show/Configure Files',
		statsTabTitle: 'Statistics',
		browseCdnTitle: 'Browse CDN Files',
	};
	const NAV_MENU_TABS = {
		readme: 'readme',
		config: 'config',
		stats: 'stats',
	};

	component.exports = {
		data () {
			return {
				_,
				collection: [],
				statsPeriods: {
					1: 'day',
					7: 'week',
					30: 'month',
					365: 'year',
				},
				statsPeriod: 30,
				packageVersionsList: [],
				navRoute: NAV_MENU_TABS.readme,
				showChartBandwidth: false,
				usageChartGroupByValues: {
					day: { value: 'day', isAvailable: true },
					week: { value: 'week', isAvailable: true },
					// since default statsPeriod is 30 (month) - group by month not available initially
					month: { value: 'month', isAvailable: false },
				},
				usageChartGroupBy: 'day',
				noPackageStatsData: false,
				noVersionsData: false,
				navMenuTitles: NAV_MENU_SHORT_TITLES,
				NAV_MENU_TABS,
			};
		},
		decorators: {
			clipboard,
			tooltip,
		},
		oninit () {
			if (!Ractive.isServer) {
				// load Package Versions List (ShowFilesTab, Top-5-files-per-version dropdown-menu)
				http.fetchPackageVersions(this.get('type'), this.get('name')).then((response) => {
					let versionsArr = response.versions.map(item => item.version);

					// This can only happen for GitHub packages.
					if (response.versions.length === 0) {
						this.set({ packageVersionsNotFound: true });

						return;
					}

					this.set('packageVersionsList', versionsArr);

					// Set version for GitHub packages.
					if (!this.get('package.version')) {
						this.set('package.version', response.versions[0].version);
					}

					// Set version for GitHub packages or when an invalid version is selected.
					if (!this.get('versionP') || versionsArr.indexOf(this.get('versionP')) === -1) {
						this.set('versionP', response.versions[0].version);
					}
				}).catch((error) => {
					this.set({ packageNotFound: true });
					console.error(`Package versions not found.`, error);
				});

				// fetch Package Version File Stats for Top-5-file-per-package-version
				this.observe('statsPeriod fileStatsVersion showChartBandwidth', () => {
					if (!this.get('statsPeriod') || !this.get('fileStatsVersion')) {
						return;
					}

					let version = this.get('fileStatsVersion');
					let period = this.get('statsPeriods')[this.get('statsPeriod')];
					let showChartBandwidth = this.get('showChartBandwidth');
					let dataType = showChartBandwidth ? 'bandwidth' : 'hits';
					let type = this.get('type');
					let name = this.get('name');

					http.fetchPackageFileStats(type, name, version, period, dataType).then((response) => {
						let filesStats = response.map(statsPerFile => ({
							file: statsPerFile.name,
							hits: statsPerFile[dataType].total,
						}));

						this.animate('filesStats', filesStats.slice(0, 5));
					});
				});

				// get Package Version Stats for Top-5-package-versions
				this.observe('statsPeriod versionP showChartBandwidth', () => {
					if (!this.get('statsPeriod') || !this.get('versionP')) { return; }

					let type = this.get('type');
					let name = this.get('name');
					let period = this.get('statsPeriods')[this.get('statsPeriod')];
					let showChartBandwidth = this.get('showChartBandwidth');
					let dataType = showChartBandwidth ? 'bandwidth' : 'hits';

					http.fetchPackageVersionsStats(type, name, period, dataType).then((response) => {
						let versionsStats = response.map(statsPerVersion => ({
							version: statsPerVersion.version,
							hits: statsPerVersion[dataType].total,
						}));

						if (versionsStats[0]) {
							this.set('fileStatsVersion', versionsStats[0].version);
						}

						this.animate('topFiveVersions', versionsStats);
					});
				});

				// change Nav Menu titles depending on the screen size (also on the resize of the page)
				// switch tab to readme after resizing (if it was Config tab)
				this.observe('screenWidth', (newScreenWidth) => {
					let actualScreenWidth = newScreenWidth ? newScreenWidth : innerWidth;
					let currentTab = this.get('navRoute');

					// set tab titles after resizing
					if (actualScreenWidth >= 768 && actualScreenWidth < 1200) {
						this.set('navMenuTitles', NAV_MENU_SHORT_TITLES);
					} else {
						this.set('navMenuTitles', NAV_MENU_FULL_TITLES);
					}

					// switch tab to Readme after resizing
					if (currentTab === NAV_MENU_TABS.config && actualScreenWidth < 768) {
						this.set('navRoute', NAV_MENU_TABS.readme);
					}
				});

				// check if Package has readme (if algolia has no Readme, we try to fetch it from https://raw.githubusercontent.com, getGHUserContentPackageReadme)
				// if readme still absent we show ConfigTab as default
				this.observe('package', () => {
					// package.readme
					let readme = this.get('package').readme;

					if (!readme || readme === 'ERROR: No README data found!') {
						this.set('navRoute', NAV_MENU_TABS.config);
					}
				});

				if (!this.get('versionP')) {
					this.set('versionP', this.get('package.version'));
				}

				// handle period changes by updating groupBy options and fetch statsChart/hitsChart data
				this.observe('statsPeriod', () => {
					let statsPeriod = this.get('statsPeriod');
					let period = this.get('statsPeriods')[statsPeriod];
					let type = this.get('type');
					let name = this.get('name');
					let dataType = this.get('showChartBandwidth') ? 'bandwidth' : 'hits';

					// once chart period is changed - update groupBy options respectively to period
					switch (period) {
						case 'year':
							this.set('usageChartGroupByValues', {
								day: { value: 'day', isAvailable: true },
								week: { value: 'week', isAvailable: true },
								month: { value: 'month', isAvailable: true },
							});

							break;

						case 'month':
							this.set('usageChartGroupByValues', {
								day: { value: 'day', isAvailable: true },
								week: { value: 'week', isAvailable: true },
								month: { value: 'month', isAvailable: false },
							});

							break;

						case 'week':
							this.set('usageChartGroupByValues', {
								day: { value: 'day', isAvailable: true },
								week: { value: 'week', isAvailable: false },
								month: { value: 'month', isAvailable: false },
							});

							break;
					}

					// prevent chart data fetching from the back when period is DAY, left it as it was prev
					if (period === 'day') { return; }

					// get data for barChart
					http.fetchPackageSummaryStats(type, name, period).then((response) => {
						if (!response.hits.total || !response.bandwidth.total) {
							this.set('noPackageStatsData', true);
							return;
						}

						this.set('noPackageStatsData', false);
						// once new data fetched we should set groupBy to default value before raw data set
						this.set('usageChartGroupBy', 'day');
						this.set('rawStatsChartData', response);
					});

					// get data for lineChart
					http.fetchPackageVersionsStats(type, name, period, dataType).then((response) => {
						if (!response.length) {
							this.set('noPackageStatsData', true);
							return;
						}

						this.set('noPackageStatsData', false);
						// once new data fetched we should set groupBy to default value before raw data set
						this.set('usageChartGroupBy', 'day');
						this.set('rawHitsChartData', response);
					});
				});

				// get data for lineChart when Request/Bandwidth switch clicked (since it is sorting on the server)
				this.observe('showChartBandwidth', (showChartBandwidth) => {
					let statsPeriod = this.get('statsPeriod');
					let period = this.get('statsPeriods')[statsPeriod];
					let type = this.get('type');
					let name = this.get('name');
					let dataType = showChartBandwidth ? 'bandwidth' : 'hits';

					http.fetchPackageVersionsStats(type, name, period, dataType).then((response) => {
						if (!response.length) {
							this.set('noPackageStatsData', true);
							return;
						}

						this.set('noPackageStatsData', false);
						this.set('rawHitsChartData', response);
					});
				}, { init: false });

				// handle raw StatsChart data and prepare it for StatsChart
				// screenWidth to observe when screen width is resized to recreate stats chart
				this.observe('rawStatsChartData showChartBandwidth usageChartGroupBy screenWidth', () => {
					let rawStatsChartData = this.get('rawStatsChartData');
					let chartPeriod = this.get('statsPeriods')[this.get('statsPeriod')];
					let showChartBandwidth = this.get('showChartBandwidth');
					let usageChartGroupBy = this.get('usageChartGroupBy');
					let screenWidth = this.get('screenWidth') ? this.get('screenWidth') : innerWidth;
					let dataType = showChartBandwidth ? 'bandwidth' : 'hits';

					// collect X-Axis dates, group data by period, get
					let {
						values,
						labels,
						labelsStartEndPeriods,
						maxRangeValue,
						valueUnits,
					} = _.getPreparedDataForBarChart(rawStatsChartData[dataType], usageChartGroupBy, chartPeriod, showChartBandwidth);

					// get bat thickness of the chart depending on screen resolution, chartPeriod and groupBy
					let chartBarThickness = _.calcChartBarThicknessByResolution(chartPeriod, usageChartGroupBy);

					// set prepared data for chart
					this.set('preparedStatsChartData', {
						data: values,
						labels,
						labelsStartEndPeriods,
						maxRangeValue,
						showChartBandwidth,
						barThickness: chartBarThickness,
						useYAxisBorderPlugin: screenWidth >= 768,
						yAxisPadding: screenWidth >= 768 ? 20 : 8,
						valueUnits,
						usageChartGroupBy,
					});
				}, { init: false });

				// handle raw HitsChart data and prepare it for HitsChart
				this.observe('rawHitsChartData showChartBandwidth usageChartGroupBy screenWidth', () => {
					let rawHitsChartData = this.get('rawHitsChartData');
					let chartPeriod = this.get('statsPeriods')[this.get('statsPeriod')];
					let showChartBandwidth = this.get('showChartBandwidth');
					let usageChartGroupBy = this.get('usageChartGroupBy');
					let screenWidth = this.get('screenWidth') ? this.get('screenWidth') : innerWidth;

					// collect versions for hitsChart Legend element
					let hitsChartLegendVersions = rawHitsChartData.map(item => ({ version: item.version }));

					// collect X-Axis dates, group data by period, get
					let {
						labels,
						maxRangeValue,
						datasets,
						labelsStartEndPeriods,
						valueUnits,
					} = _.getPreparedDataForLineChart(rawHitsChartData, usageChartGroupBy, chartPeriod, showChartBandwidth);

					this.set('preparedHitsChartData', {
						datasets,
						labels,
						labelsStartEndPeriods,
						maxRangeValue,
						showChartBandwidth,
						useYAxisBorderPlugin: screenWidth >= 768,
						yAxisPadding: screenWidth >= 768 ? 30 : 18,
						valueUnits,
						usageChartGroupBy,
					});

					this.set('hitsChartLegendVersions', hitsChartLegendVersions);
				}, { init: false });
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				let statsChart;
				let hitsChart;

				// create barChart
				this.observe('preparedStatsChartData', (preparedStatsChartData) => {
					let {
						labels,
						maxRangeValue,
						data,
						showChartBandwidth,
						barThickness,
						useYAxisBorderPlugin,
						yAxisPadding,
						labelsStartEndPeriods,
						valueUnits,
						usageChartGroupBy,
					} = preparedStatsChartData;
					let statsChartCanvasEl = this.find('#stats-chart');

					if (!preparedStatsChartData || !statsChartCanvasEl) { return; }

					if (statsChart) {
						statsChart.destroy();
						statsChart = null;
					}

					let chartData = {
						labels,
						datasets: [{
							data,
							borderWidth: 0,
							barThickness,
							hoverBackgroundColor: '#F65128',
						}],
						labelsStartEndPeriods,
						valueUnits,
						usageChartGroupBy,
					};
					let chartSettings = {
						useYAxisBorderPlugin,
						useExternalTooltip: true,
						useImprovedTooltip: true,
						externalTooltipVerticalOffset: 40,
					};
					let maxRangeMagnitude = Math.floor(Math.log10(maxRangeValue));
					let chartConfig = {
						options: {
							scales: {
								x: {
									display: true,
									ticks: {
										color: '#5C667A',
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
											lineHeight: 2,
										},
										// return nothing when labelValue array is empty
										// this way we will not get italicized text when all ticks can't be displayed at once normally
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);

											if (labelValue.length) {
												return labelValue;
											}
										},
									},
									grid: {
										display: false,
										drawBorder: false,
									},
								},
								y: {
									display: true,
									min: 0,
									suggestedMax: Math.ceil(maxRangeValue / Math.pow(10, maxRangeMagnitude)) * Math.pow(10, maxRangeMagnitude),
									ticks: {
										padding: yAxisPadding,
										count: 9,
										color: '#5C667A',
										crossAlign: 'near',
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
										},
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);
											let valueByMagnitude = _.getValueByMagnitude(Math.round(labelValue.replace(/,/g, '')), 'round', 1, false);

											if (_.isMobileScreen()) {
												return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatToShortNumber(valueByMagnitude);
											}

											return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatNumber(valueByMagnitude);
										},
									},
									grid: {
										display: false,
										drawBorder: false,
									},
								},
							},
						},
					};

					statsChart = createBarChart(statsChartCanvasEl, chartData, chartSettings, chartConfig);
				}, { init: false });

				// create lineChart
				this.observe('preparedHitsChartData', (preparedHitsChartData) => {
					let {
						datasets,
						labels,
						maxRangeValue,
						useYAxisBorderPlugin,
						showChartBandwidth,
						yAxisPadding,
						labelsStartEndPeriods,
						valueUnits,
						usageChartGroupBy,
					} = preparedHitsChartData;
					let hitsChartCanvasEl = this.find('#hits-chart');

					if (!preparedHitsChartData || !hitsChartCanvasEl) { return; }

					if (hitsChart) {
						hitsChart.destroy();
						hitsChart = null;
					}

					let chartData = {
						labels,
						datasets,
						labelsStartEndPeriods,
						valueUnits,
						usageChartGroupBy,
					};
					let chartSettings = {
						useYAxisBorderPlugin,
						useExternalTooltip: true,
						useImprovedTooltip: true,
						plugins: {
							useExternalTooltip: true,
						},
					};
					let maxRangeMagnitude = Math.floor(Math.log10(maxRangeValue));
					let chartConfig = {
						options: {
							scales: {
								x: {
									display: true,
									ticks: {
										autoSkip: false,
										color: '#5C667A',
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
											lineHeight: 2,
										},
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);

											if (labelValue.length) {
												return labelValue;
											}
										},
									},
									grid: {
										display: false,
										drawBorder: false,
									},
								},
								y: {
									display: true,
									min: 0,
									suggestedMax: Math.ceil(maxRangeValue / Math.pow(10, maxRangeMagnitude)) * Math.pow(10, maxRangeMagnitude),
									ticks: {
										padding: yAxisPadding,
										count: 9,
										color: '#5C667A',
										crossAlign: 'near',
										font: {
											size: 12,
											family: 'Lexend, sans-serif',
										},
										callback (tickIdx) {
											let labelValue = this.getLabelForValue(tickIdx);
											let valueByMagnitude = _.getValueByMagnitude(Math.round(labelValue.replace(/,/g, '')), 'round', 1, false);

											if (_.isMobileScreen()) {
												return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatToShortNumber(valueByMagnitude);
											}

											return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} ${valueUnits}` : _.formatNumber(valueByMagnitude);
										},
									},
									grid: {
										drawBorder: false,
										color: '#CFD6DD',
										tickLength: 0,
									},
								},
							},
						},
					};

					hitsChart = createLineChart(hitsChartCanvasEl, chartData, chartSettings, chartConfig);
				}, { init: false });

				// detect window resize
				window.addEventListener('resize', debounce(throttle(() => this.set('screenWidth', innerWidth), 200)));
			}
		},
	};
</script>
