<div class="c-range-slider">
	{{#if useDefaultHeader}}
		<div class="range-slider-header">
			{{creditsPerDollar * donationValue}} credits/donation
		</div>
	{{elseif @this.partials.customHeader}}
		{{>customHeader}}
	{{/if}}

	<div id="slider-container" class="range-slider">
		<div id="slider-line" class="range-slider_line"></div>
		<div id="slider-knob" class="range-slider_knob"></div>
	</div>

	{{#if partsLabelsData && partsLabelsData.length === partsCount}}
		<div id="slider-labels" class="range-slider-labels"></div>
	{{/if}}
</div>

<script>
	component.exports = {
		data () {
			return {
				useDefaultHeader: true,
				creditsPerDollar: 200,
				donationValue: 1,
				partsCount: 9,
				partsGap: 2,
				sliderPosition: 0,
				partsElements: [],
				partWidth: null,
				maxSliderPosition: null,
				partClassname: 'range-slider_line_part',
				gapClassname: 'range-slider_line_gap',
				partLabelClassname: 'range-slider-labels_label',
				partsLabelsData: [
					{
						displayed: '1$',
						value: '1',
					},
					{
						displayed: '2$',
						value: '2',
					},
					{
						displayed: '4$',
						value: '4',
					},
					{
						displayed: '8$',
						value: '8',
					},
					{
						displayed: '16$',
						value: '16',
					},
					{
						displayed: '32$',
						value: '32',
					},
					{
						displayed: '64$',
						value: '64',
					},
					{
						displayed: '128$',
						value: '128',
					},
					{
						displayed: 'Custom',
						value: '0',
					},
				],
			};
		},
		onrender () {
			if (!Ractive.isServer) {
				let partsCount = this.get('partsCount');
				let partsGap = this.get('partsGap');
				let partsLabelsData = this.get('partsLabelsData');
				let sliderContainer = document.getElementById('slider-container');
				let sliderKnob = document.getElementById('slider-knob');
				let sliderLine = document.getElementById('slider-line');
				let sliderLabels = document.getElementById('slider-labels');
				let parts = [];
				let partsLabels = [];

				// divide the line with parts and gaps, create parts labels
				for (let i = 0; i < partsCount; i++) {
					let partEl = document.createElement('div');

					partEl.className = this.get('partClassname');
					parts.push(partEl);
					sliderLine.appendChild(partEl);

					// add gap except after the last part
					if (i < partsCount - 1) {
						let gapEl = document.createElement('div');

						gapEl.className = this.get('gapClassname');
						sliderLine.appendChild(gapEl);
					}

					// create parts labels
					if (partsLabelsData && partsLabelsData.length === partsCount) {
						let partLabelEl = document.createElement('div');

						partLabelEl.className = this.get('partLabelClassname');
						partLabelEl.textContent = partsLabelsData[i].displayed;
						partsLabels.push(partLabelEl);
						sliderLabels.appendChild(partLabelEl);

						// add gap except after the last part
						if (i < partsLabelsData.length - 1) {
							let gapEl = document.createElement('div');

							gapEl.className = this.get('gapClassname');
							sliderLabels.appendChild(gapEl);
						}
					}
				}

				let partWidth = parts[0].offsetWidth + partsGap;
				let maxSliderPosition = partWidth * partsCount;

				this.set('partsElements', parts);
				this.set('partWidth', partWidth);
				this.set('maxSliderPosition', maxSliderPosition);

				// set slider with mouse click
				sliderContainer.addEventListener('click', (event) => {
					let rect = sliderContainer.getBoundingClientRect();
					let x = event.clientX - rect.left;

					this.moveSliderToClosestPart(x);
				});

				// handle the sliderKnob dragging
				sliderKnob.addEventListener('mousedown', (event) => {
					event.preventDefault();

					let onMouseMove = (event) => {
						let rect = sliderContainer.getBoundingClientRect();
						let x = event.clientX - rect.left;

						this.moveSliderToClosestPart(x);
					};

					let onMouseUp = () => {
						document.removeEventListener('mousemove', onMouseMove);
						document.removeEventListener('mouseup', onMouseUp);
					};

					document.addEventListener('mousemove', onMouseMove);
					document.addEventListener('mouseup', onMouseUp);
				});

				// handle keyboard controls
				document.addEventListener('keydown', (event) => {
					let sliderPosition = this.get('sliderPosition');

					if (event.key === 'ArrowLeft') {
						sliderPosition = Math.max(0, sliderPosition - partWidth);
					} else if (event.key === 'ArrowRight') {
						sliderPosition = Math.min(maxSliderPosition, sliderPosition + partWidth);
					}

					this.set('sliderPosition', sliderPosition);

					this.updateSliderPosition();
				});

				// initiate the slider
				this.updateSliderPosition();
			}
		},
		updateSliderPosition () {
			let sliderPosition = this.get('sliderPosition');
			let partsElements = this.get('partsElements');
			let partWidth = this.get('partWidth');
			let sliderKnob = document.getElementById('slider-knob');

			sliderKnob.style.left = `${sliderPosition}px`;

			// highlight parts to the left of the sliderKnob
			partsElements.forEach((partEl, idx) => {
				if (idx * partWidth < sliderPosition) {
					partEl.style.backgroundColor = '#17d4a7';
				} else {
					partEl.style.backgroundColor = '#e7e7ee';
				}
			});
		},
		moveSliderToClosestPart (x) {
			let partWidth = this.get('partWidth');
			let maxSliderPosition = this.get('maxSliderPosition');

			// calculate closest part
			let sliderPosition = Math.round(x / partWidth) * partWidth;

			// snap to the exact start or end of the slider line
			if (sliderPosition < 0) {
				sliderPosition = 0;
			} else if (sliderPosition > maxSliderPosition) {
				sliderPosition = maxSliderPosition;
			}

			this.set('sliderPosition', sliderPosition);

			this.updateSliderPosition();
		},
	};
</script>
